[{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702710","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702710","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702710,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3MTA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:49:40Z","updated_at":"2025-01-21T13:13:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>I tried running the attached test against the current master branch and was not able to reproduce a failure. We should probably add the test to the code for completeness, but otherwise I'm tempted to suggest that we close this as 'Cannot Reproduce'</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702710/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50921130","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50921130","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50921130,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTIxMTMw","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:50:55Z","updated_at":"2014-08-01T18:50:55Z","author_association":"CONTRIBUTOR","body":"Just to be sure, I went back and instrumented the entire refresh() section like this:\n\n```\n        private void refresh() throws Exception\n        {\n            for ( int i = 0; i < 20; ++i )\n            {\n                executorService.submit(new Callable<Void>()\n                {\n                    @Override\n                    public Void call() throws Exception\n                    {\n                        outstandingOps.addAndGet(2);\n                        Thread.sleep(random.nextInt(30));\n                        doRefreshData();\n                        Thread.sleep(random.nextInt(30));\n                        doRefreshChildren();\n                        return null;\n                    }\n                });\n            }\n        }\n\n        private void doRefreshChildren() throws Exception\n        {\n            GetChildrenBuilder children1 = client.getChildren();\n            Thread.sleep(random.nextInt(30));\n            BackgroundPathable<List<String>> listBackgroundPathable = children1.usingWatcher(this);\n            Thread.sleep(random.nextInt(30));\n            Pathable<List<String>> listPathable = listBackgroundPathable.inBackground(this);\n            Thread.sleep(random.nextInt(30));\n            listPathable.forPath(path);\n        }\n```\n\nAll the test still pass (just way more slowly) despite there being 20 threads racing each other on every op.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50921130/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695850","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695850","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695850,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4NTA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:51:04Z","updated_at":"2025-01-21T13:10:44Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50921130\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50921130</a></p>\n\n<p>    Just to be sure, I went back and instrumented the entire refresh() section like this:</p>\n\n<p>    ```<br/>\n    private void refresh() throws Exception<br/>\n    {<br/>\nfor ( int i = 0; i < 20; ++i )<br/>\n{<br/>\n    executorService.submit(new Callable<Void>()<br/>\n    {<br/>\n@Override<br/>\npublic Void call() throws Exception</p>\n{\n    outstandingOps.addAndGet(2);\n    Thread.sleep(random.nextInt(30));\n    doRefreshData();\n    Thread.sleep(random.nextInt(30));\n    doRefreshChildren();\n    return null;\n}\n<p>    });<br/>\n}<br/>\n    }</p>\n\n<p>    private void doRefreshChildren() throws Exception</p>\n    {\nGetChildrenBuilder children1 = client.getChildren();\nThread.sleep(random.nextInt(30));\nBackgroundPathable<List<String>> listBackgroundPathable = children1.usingWatcher(this);\nThread.sleep(random.nextInt(30));\nPathable<List<String>> listPathable = listBackgroundPathable.inBackground(this);\nThread.sleep(random.nextInt(30));\nlistPathable.forPath(path);\n    }\n<p>    ```</p>\n\n<p>    All the test still pass (just way more slowly) despite there being 20 threads racing each other on every op.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695850/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711442","html_url":"https://github.com/apache/curator/issues/656#issuecomment-2604711442","issue_url":"https://api.github.com/repos/apache/curator/issues/656","id":2604711442,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE0NDI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T19:14:48Z","updated_at":"2025-01-21T13:17:25Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>This is a core design decision of Curator. Exception is always thrown.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711442/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711447","html_url":"https://github.com/apache/curator/issues/656#issuecomment-2604711447","issue_url":"https://api.github.com/repos/apache/curator/issues/656","id":2604711447,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE0NDc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T20:44:18Z","updated_at":"2025-01-21T13:17:25Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>Leave open so that the community can vote on this. My personal vote is a huge -1 binding. If I had to do it over again I'd getting rid of checked exceptions altogether.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711447/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711283","html_url":"https://github.com/apache/curator/issues/655#issuecomment-2604711283","issue_url":"https://api.github.com/repos/apache/curator/issues/655","id":2604711283,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEyODM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T21:33:37Z","updated_at":"2025-01-21T13:17:21Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=benjamin.jaton\">benjamin.jaton</a>:</i>\n<p>Note that there is no need to use a NodeCache in the Test.java, I could reproduce the issue without it.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711283/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711025","html_url":"https://github.com/apache/curator/issues/653#issuecomment-2604711025","issue_url":"https://api.github.com/repos/apache/curator/issues/653","id":2604711025,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEwMjU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-02T22:51:21Z","updated_at":"2025-01-21T13:17:14Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cammckenzie\">cammckenzie</a>:</i>\n<p>Regression all seems to run fine with the getACL and setACL methods removed from the NamespaceFacade. <a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\" class=\"user-hover\" rel=\"randgalt\">Jordan Zimmerman</a>, do you know why this was implemented in this way? I'm just concerned that the ACL stuff was implemented to bypass namespaces for some reason.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711025/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711026","html_url":"https://github.com/apache/curator/issues/653#issuecomment-2604711026","issue_url":"https://api.github.com/repos/apache/curator/issues/653","id":2604711026,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEwMjY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T00:13:48Z","updated_at":"2025-01-21T13:17:14Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user cammckenzie opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/32\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/32</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-132\" title=\"setACL doesn&#39;t work with namespaced curator\" class=\"issue-link\" data-issue-key=\"CURATOR-132\"><del>CURATOR-132</del></a> - Modified the NamespaceFacade so that it does not proxy</p>\n\n<p>    Modified the NamespaceFacade so that it does not proxy getACL() and setACL() calls to the underlying client (which is not namespace aware), and instead handles them itself.</p>\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/apache/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-132\" title=\"setACL doesn&#39;t work with namespaced curator\" class=\"issue-link\" data-issue-key=\"CURATOR-132\"><del>CURATOR-132</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/32.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/32.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #32</p>\n\n<hr />\n<p>commit 97351385561f3038b2aba9a25a617a204a14e023<br/>\nAuthor: Cam McKenzie <cammckenzie@apache.org><br/>\nDate:   2014-08-04T00:04:22Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-132\" title=\"setACL doesn&#39;t work with namespaced curator\" class=\"issue-link\" data-issue-key=\"CURATOR-132\"><del>CURATOR-132</del></a> - Modified the NamespaceFacade so that it does not proxy<br/>\n    getACL() and setACL() calls to the underlying client (which is not<br/>\n    namespace aware), and instead handles them itself.</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711026/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51007885","html_url":"https://github.com/apache/curator/pull/32#issuecomment-51007885","issue_url":"https://api.github.com/repos/apache/curator/issues/32","id":51007885,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDA3ODg1","user":{"login":"cammckenzie","id":7763121,"node_id":"MDQ6VXNlcjc3NjMxMjE=","avatar_url":"https://avatars.githubusercontent.com/u/7763121?v=4","gravatar_id":"","url":"https://api.github.com/users/cammckenzie","html_url":"https://github.com/cammckenzie","followers_url":"https://api.github.com/users/cammckenzie/followers","following_url":"https://api.github.com/users/cammckenzie/following{/other_user}","gists_url":"https://api.github.com/users/cammckenzie/gists{/gist_id}","starred_url":"https://api.github.com/users/cammckenzie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cammckenzie/subscriptions","organizations_url":"https://api.github.com/users/cammckenzie/orgs","repos_url":"https://api.github.com/users/cammckenzie/repos","events_url":"https://api.github.com/users/cammckenzie/events{/privacy}","received_events_url":"https://api.github.com/users/cammckenzie/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T00:14:18Z","updated_at":"2014-08-04T00:14:18Z","author_association":"CONTRIBUTOR","body":"The only question is why it was implemented in this way originally? The setACL() and getACL() methods were explicitly overridden to defer to the underlying (non namespace aware) client.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51007885/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711029","html_url":"https://github.com/apache/curator/issues/653#issuecomment-2604711029","issue_url":"https://api.github.com/repos/apache/curator/issues/653","id":2604711029,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEwMjk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T00:14:30Z","updated_at":"2025-01-21T13:17:15Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/32#issuecomment-51007885\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/32#issuecomment-51007885</a></p>\n\n<p>    The only question is why it was implemented in this way originally? The setACL() and getACL() methods were explicitly overridden to defer to the underlying (non namespace aware) client.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711029/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51008324","html_url":"https://github.com/apache/curator/pull/31#issuecomment-51008324","issue_url":"https://api.github.com/repos/apache/curator/issues/31","id":51008324,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDA4MzI0","user":{"login":"cammckenzie","id":7763121,"node_id":"MDQ6VXNlcjc3NjMxMjE=","avatar_url":"https://avatars.githubusercontent.com/u/7763121?v=4","gravatar_id":"","url":"https://api.github.com/users/cammckenzie","html_url":"https://github.com/cammckenzie","followers_url":"https://api.github.com/users/cammckenzie/followers","following_url":"https://api.github.com/users/cammckenzie/following{/other_user}","gists_url":"https://api.github.com/users/cammckenzie/gists{/gist_id}","starred_url":"https://api.github.com/users/cammckenzie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cammckenzie/subscriptions","organizations_url":"https://api.github.com/users/cammckenzie/orgs","repos_url":"https://api.github.com/users/cammckenzie/repos","events_url":"https://api.github.com/users/cammckenzie/events{/privacy}","received_events_url":"https://api.github.com/users/cammckenzie/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T00:32:41Z","updated_at":"2014-08-04T00:32:41Z","author_association":"CONTRIBUTOR","body":"Thanks, looks good. I just had a quick look through the code for any other cases, and there are a couple in ConnectionStateListener. Lines 80 and 201. I think that at least the one at line 80 should also be removed. The line 201 one can be suppressed via a property, so maybe that one is not so important. What do you think?\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51008324/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701470","html_url":"https://github.com/apache/curator/issues/592#issuecomment-2604701470","issue_url":"https://api.github.com/repos/apache/curator/issues/592","id":2604701470,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDE0NzA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T00:32:53Z","updated_at":"2025-01-21T13:13:09Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/31#issuecomment-51008324\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/31#issuecomment-51008324</a></p>\n\n<p>    Thanks, looks good. I just had a quick look through the code for any other cases, and there are a couple in ConnectionStateListener. Lines 80 and 201. I think that at least the one at line 80 should also be removed. The line 201 one can be suppressed via a property, so maybe that one is not so important. What do you think?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701470/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700890","html_url":"https://github.com/apache/curator/issues/588#issuecomment-2604700890","issue_url":"https://api.github.com/repos/apache/curator/issues/588","id":2604700890,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDA4OTA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T00:54:17Z","updated_at":"2025-01-21T13:12:56Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/30#discussion_r15737880\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/30#discussion_r15737880</a></p>\n\n<p>    &#8212; Diff: curator-x-discovery/src/main/java/org/apache/curator/x/discovery/ServiceDiscoveryBuilder.java &#8212;<br/>\n    @@ -29,6 +29,7 @@<br/>\n private String  basePath;<br/>\n private InstanceSerializer<T>   serializer;<br/>\n private ServiceInstance<T>      thisInstance;<br/>\n    +    private Class<T>payloadClass;</p>\n\n<p> /**</p>\n<ul>\n\t<li>Return a new builder. The builder will be defaulted with a \n{@link JsonInstanceSerializer}\n<p>.</p>\n\t<ul class=\"alternate\" type=\"square\">\n\t\t<li>\n\t\t<ul class=\"alternate\" type=\"square\">\n\t\t\t<li>End diff &#8211;</li>\n\t\t</ul>\n\t\t</li>\n\t</ul>\n\t</li>\n</ul>\n\n\n<p>    This comment about defaulting the serializer should be moved to the build() method.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700890/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700895","html_url":"https://github.com/apache/curator/issues/588#issuecomment-2604700895","issue_url":"https://api.github.com/repos/apache/curator/issues/588","id":2604700895,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDA4OTU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T00:56:49Z","updated_at":"2025-01-21T13:12:56Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/30#discussion_r15737899\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/30#discussion_r15737899</a></p>\n\n<p>    &#8212; Diff: curator-x-discovery/src/test/java/org/apache/curator/x/discovery/details/TestServiceDiscoveryBuilder.java &#8212;<br/>\n    @@ -0,0 +1,68 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +package org.apache.curator.x.discovery.details;<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    This test should be in org.apache.curator.x.discovery to match the implementation.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700895/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51060899","html_url":"https://github.com/apache/curator/pull/31#issuecomment-51060899","issue_url":"https://api.github.com/repos/apache/curator/issues/31","id":51060899,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMDYwODk5","user":{"login":"madrob","id":1592330,"node_id":"MDQ6VXNlcjE1OTIzMzA=","avatar_url":"https://avatars.githubusercontent.com/u/1592330?v=4","gravatar_id":"","url":"https://api.github.com/users/madrob","html_url":"https://github.com/madrob","followers_url":"https://api.github.com/users/madrob/followers","following_url":"https://api.github.com/users/madrob/following{/other_user}","gists_url":"https://api.github.com/users/madrob/gists{/gist_id}","starred_url":"https://api.github.com/users/madrob/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/madrob/subscriptions","organizations_url":"https://api.github.com/users/madrob/orgs","repos_url":"https://api.github.com/users/madrob/repos","events_url":"https://api.github.com/users/madrob/events{/privacy}","received_events_url":"https://api.github.com/users/madrob/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T13:41:15Z","updated_at":"2014-08-04T13:41:15Z","author_association":"CONTRIBUTOR","body":"The only ConnectionStateListener that I can find is a 30 line interface in curator-framework. Can you be more specific with where you're looking, I'm having some trouble here. Thanks.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51060899/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701476","html_url":"https://github.com/apache/curator/issues/592#issuecomment-2604701476","issue_url":"https://api.github.com/repos/apache/curator/issues/592","id":2604701476,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDE0NzY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T13:41:33Z","updated_at":"2025-01-21T13:13:09Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user madrob commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/31#issuecomment-51060899\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/31#issuecomment-51060899</a></p>\n\n<p>    The only ConnectionStateListener that I can find is a 30 line interface in curator-framework. Can you be more specific with where you're looking, I'm having some trouble here. Thanks.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701476/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700899","html_url":"https://github.com/apache/curator/issues/588#issuecomment-2604700899","issue_url":"https://api.github.com/repos/apache/curator/issues/588","id":2604700899,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDA4OTk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T13:47:11Z","updated_at":"2025-01-21T13:12:56Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user madrob commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/30#discussion_r15755406\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/30#discussion_r15755406</a></p>\n\n<p>    &#8212; Diff: curator-x-discovery/src/test/java/org/apache/curator/x/discovery/details/TestServiceDiscoveryBuilder.java &#8212;<br/>\n    @@ -0,0 +1,68 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +package org.apache.curator.x.discovery.details;<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    I put the test in o.a.c.x.discovery.details so that I could use the package level access methods on ServiceDiscoveryImpl to verify the serializer class. If I move the package up, then I guess I can still get at it using reflection, or by increasing the visibility of ServiceDiscoveryImpl.getSerializer(). Your call.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700899/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604709130","html_url":"https://github.com/apache/curator/issues/641#issuecomment-2604709130","issue_url":"https://api.github.com/repos/apache/curator/issues/641","id":2604709130,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDkxMzA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T14:53:44Z","updated_at":"2025-01-21T13:16:27Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>There are already builders and fluent-ish APIs in other parts of the code, so it seems like it would be a good fit.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604709130/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604698559","html_url":"https://github.com/apache/curator/issues/571#issuecomment-2604698559","issue_url":"https://api.github.com/repos/apache/curator/issues/571","id":2604698559,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTg1NTk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T17:35:24Z","updated_at":"2025-01-21T13:11:52Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>I tried this earlier today, and attempting to create \"/\" under a non-existent multi-node chroot did fail for me using raw zk handles.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604698559/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700908","html_url":"https://github.com/apache/curator/issues/588#issuecomment-2604700908","issue_url":"https://api.github.com/repos/apache/curator/issues/588","id":2604700908,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDA5MDg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T21:36:23Z","updated_at":"2025-01-21T13:12:56Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/30#discussion_r15782878\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/30#discussion_r15782878</a></p>\n\n<p>    &#8212; Diff: curator-x-discovery/src/test/java/org/apache/curator/x/discovery/details/TestServiceDiscoveryBuilder.java &#8212;<br/>\n    @@ -0,0 +1,68 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +package org.apache.curator.x.discovery.details;<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    All good</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700908/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51121406","html_url":"https://github.com/apache/curator/pull/31#issuecomment-51121406","issue_url":"https://api.github.com/repos/apache/curator/issues/31","id":51121406,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMTIxNDA2","user":{"login":"cammckenzie","id":7763121,"node_id":"MDQ6VXNlcjc3NjMxMjE=","avatar_url":"https://avatars.githubusercontent.com/u/7763121?v=4","gravatar_id":"","url":"https://api.github.com/users/cammckenzie","html_url":"https://github.com/cammckenzie","followers_url":"https://api.github.com/users/cammckenzie/followers","following_url":"https://api.github.com/users/cammckenzie/following{/other_user}","gists_url":"https://api.github.com/users/cammckenzie/gists{/gist_id}","starred_url":"https://api.github.com/users/cammckenzie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cammckenzie/subscriptions","organizations_url":"https://api.github.com/users/cammckenzie/orgs","repos_url":"https://api.github.com/users/cammckenzie/repos","events_url":"https://api.github.com/users/cammckenzie/events{/privacy}","received_events_url":"https://api.github.com/users/cammckenzie/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T21:38:19Z","updated_at":"2014-08-04T21:38:19Z","author_association":"CONTRIBUTOR","body":"Sorry, org.apache.curator.ConnectionState\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51121406/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701483","html_url":"https://github.com/apache/curator/issues/592#issuecomment-2604701483","issue_url":"https://api.github.com/repos/apache/curator/issues/592","id":2604701483,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDE0ODM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T21:38:47Z","updated_at":"2025-01-21T13:13:09Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/31#issuecomment-51121406\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/31#issuecomment-51121406</a></p>\n\n<p>    Sorry, org.apache.curator.ConnectionState</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701483/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51126572","html_url":"https://github.com/apache/curator/pull/31#issuecomment-51126572","issue_url":"https://api.github.com/repos/apache/curator/issues/31","id":51126572,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMTI2NTcy","user":{"login":"madrob","id":1592330,"node_id":"MDQ6VXNlcjE1OTIzMzA=","avatar_url":"https://avatars.githubusercontent.com/u/1592330?v=4","gravatar_id":"","url":"https://api.github.com/users/madrob","html_url":"https://github.com/madrob","followers_url":"https://api.github.com/users/madrob/followers","following_url":"https://api.github.com/users/madrob/following{/other_user}","gists_url":"https://api.github.com/users/madrob/gists{/gist_id}","starred_url":"https://api.github.com/users/madrob/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/madrob/subscriptions","organizations_url":"https://api.github.com/users/madrob/orgs","repos_url":"https://api.github.com/users/madrob/repos","events_url":"https://api.github.com/users/madrob/events{/privacy}","received_events_url":"https://api.github.com/users/madrob/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T22:25:40Z","updated_at":"2014-08-04T22:25:40Z","author_association":"CONTRIBUTOR","body":"Updated the PR to remove the first logging in ConnectionState. I think you're right about leaving the second one in, since it's covered by a boolean flag.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51126572/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701492","html_url":"https://github.com/apache/curator/issues/592#issuecomment-2604701492","issue_url":"https://api.github.com/repos/apache/curator/issues/592","id":2604701492,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDE0OTI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T22:26:05Z","updated_at":"2025-01-21T13:13:10Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user madrob commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/31#issuecomment-51126572\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/31#issuecomment-51126572</a></p>\n\n<p>    Updated the PR to remove the first logging in ConnectionState. I think you're right about leaving the second one in, since it's covered by a boolean flag.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701492/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51126770","html_url":"https://github.com/apache/curator/pull/30#issuecomment-51126770","issue_url":"https://api.github.com/repos/apache/curator/issues/30","id":51126770,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMTI2Nzcw","user":{"login":"madrob","id":1592330,"node_id":"MDQ6VXNlcjE1OTIzMzA=","avatar_url":"https://avatars.githubusercontent.com/u/1592330?v=4","gravatar_id":"","url":"https://api.github.com/users/madrob","html_url":"https://github.com/madrob","followers_url":"https://api.github.com/users/madrob/followers","following_url":"https://api.github.com/users/madrob/following{/other_user}","gists_url":"https://api.github.com/users/madrob/gists{/gist_id}","starred_url":"https://api.github.com/users/madrob/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/madrob/subscriptions","organizations_url":"https://api.github.com/users/madrob/orgs","repos_url":"https://api.github.com/users/madrob/repos","events_url":"https://api.github.com/users/madrob/events{/privacy}","received_events_url":"https://api.github.com/users/madrob/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T22:27:51Z","updated_at":"2014-08-04T22:27:51Z","author_association":"CONTRIBUTOR","body":"Updated the javadoc. Left the test in the same package, but I guess I could add docs there too.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51126770/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700914","html_url":"https://github.com/apache/curator/issues/588#issuecomment-2604700914","issue_url":"https://api.github.com/repos/apache/curator/issues/588","id":2604700914,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDA5MTQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-04T22:28:07Z","updated_at":"2025-01-21T13:12:56Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user madrob commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/30#issuecomment-51126770\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/30#issuecomment-51126770</a></p>\n\n<p>    Updated the javadoc. Left the test in the same package, but I guess I could add docs there too.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700914/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700917","html_url":"https://github.com/apache/curator/issues/588#issuecomment-2604700917","issue_url":"https://api.github.com/repos/apache/curator/issues/588","id":2604700917,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDA5MTc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T04:11:15Z","updated_at":"2025-01-21T13:12:56Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user asfgit closed the pull request at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/30\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/30</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700917/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51149193","html_url":"https://github.com/apache/curator/pull/31#issuecomment-51149193","issue_url":"https://api.github.com/repos/apache/curator/issues/31","id":51149193,"node_id":"MDEyOklzc3VlQ29tbWVudDUxMTQ5MTkz","user":{"login":"cammckenzie","id":7763121,"node_id":"MDQ6VXNlcjc3NjMxMjE=","avatar_url":"https://avatars.githubusercontent.com/u/7763121?v=4","gravatar_id":"","url":"https://api.github.com/users/cammckenzie","html_url":"https://github.com/cammckenzie","followers_url":"https://api.github.com/users/cammckenzie/followers","following_url":"https://api.github.com/users/cammckenzie/following{/other_user}","gists_url":"https://api.github.com/users/cammckenzie/gists{/gist_id}","starred_url":"https://api.github.com/users/cammckenzie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cammckenzie/subscriptions","organizations_url":"https://api.github.com/users/cammckenzie/orgs","repos_url":"https://api.github.com/users/cammckenzie/repos","events_url":"https://api.github.com/users/cammckenzie/events{/privacy}","received_events_url":"https://api.github.com/users/cammckenzie/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T04:35:36Z","updated_at":"2014-08-05T04:36:37Z","author_association":"CONTRIBUTOR","body":"All good, thanks.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51149193/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701498","html_url":"https://github.com/apache/curator/issues/592#issuecomment-2604701498","issue_url":"https://api.github.com/repos/apache/curator/issues/592","id":2604701498,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDE0OTg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T04:35:55Z","updated_at":"2025-01-21T13:13:10Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/31#issuecomment-51149193\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/31#issuecomment-51149193</a></p>\n\n<p>    The new unit test ended up in both the discovery and discovery.details packages (maybe something broke in the merge), so I removed the one in discovery as it didn't compile (package protection issues). Removed some unused imports. Good to go now, thanks.</p>\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701498/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701502","html_url":"https://github.com/apache/curator/issues/592#issuecomment-2604701502","issue_url":"https://api.github.com/repos/apache/curator/issues/592","id":2604701502,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDE1MDI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T05:09:34Z","updated_at":"2025-01-21T13:13:10Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user asfgit closed the pull request at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/31\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/31</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701502/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695860","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695860","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695860,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4NjA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T14:01:02Z","updated_at":"2025-01-21T13:10:44Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15813324\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15813324</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/test/java/org/apache/curator/framework/recipes/cache/BaseTestTreeCache.java &#8212;<br/>\n    @@ -0,0 +1,173 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.CuratorFrameworkFactory;<br/>\n    +import org.apache.curator.framework.api.UnhandledErrorListener;<br/>\n    +import org.apache.curator.retry.RetryOneTime;<br/>\n    +import org.apache.curator.test.BaseClassForTests;<br/>\n    +import org.apache.curator.test.Timing;<br/>\n    +import org.apache.curator.utils.CloseableUtils;<br/>\n    +import org.testng.Assert;<br/>\n    +import org.testng.annotations.AfterMethod;<br/>\n    +import org.testng.annotations.BeforeMethod;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.List;<br/>\n    +import java.util.concurrent.BlockingQueue;<br/>\n    +import java.util.concurrent.LinkedBlockingQueue;<br/>\n    +import java.util.concurrent.TimeUnit;<br/>\n    +<br/>\n    +public class BaseTestTreeCache extends BaseClassForTests<br/>\n    +{<br/>\n    +    private final Timing timing = new Timing();<br/>\n    +    CuratorFramework client;<br/>\n    +    TreeCache cache;<br/>\n    +    private List<Throwable> exceptions;<br/>\n    +    private BlockingQueue<TreeCacheEvent> events;<br/>\n    +    TreeCacheListener eventListener;<br/>\n    +<br/>\n    +    /**<br/>\n    +     * A TreeCache that records exceptions and automatically adds a listener.<br/>\n    +     */<br/>\n    +    class TreeCache extends org.apache.curator.framework.recipes.cache.TreeCache<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Why is the base class spelled out with a FQPN?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695860/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695864","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695864","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695864,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4NjQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T14:03:32Z","updated_at":"2025-01-21T13:10:44Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15813477\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15813477</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/test/java/org/apache/curator/framework/recipes/cache/TestTreeCache.java &#8212;<br/>\n    @@ -0,0 +1,335 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.collect.ImmutableSet;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.test.KillSession;<br/>\n    +import org.apache.curator.utils.CloseableUtils;<br/>\n    +import org.apache.zookeeper.CreateMode;<br/>\n    +import org.testng.Assert;<br/>\n    +import org.testng.annotations.Test;<br/>\n    +import java.util.concurrent.Semaphore;<br/>\n    +<br/>\n    +public class TestTreeCache extends BaseTestTreeCache<br/>\n    +{<br/>\n    +    @Test<br/>\n    +    public void testStartup() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/1\", \"one\".getBytes());\n    +client.create().forPath(\"/test/2\", \"two\".getBytes());\n    +client.create().forPath(\"/test/3\", \"three\".getBytes());\n    +client.create().forPath(\"/test/2/sub\", \"two-sub\".getBytes());\n    +\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/1\", \"one\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/2\", \"two\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/3\", \"three\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/2/sub\", \"two-sub\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"1\", \"2\", \"3\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/1\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/2\").keySet(), ImmutableSet.of(\"sub\"));\n    +Assert.assertNull(cache.getCurrentChildren(\"/test/non_exist\"));\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testStartEmpty() throws Exception<br/>\n    +    </p>\n{\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +\n    +client.create().forPath(\"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testAsyncInitialPopulation() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/one\", \"hey there\".getBytes());\n    +\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testFromRoot() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/one\", \"hey there\".getBytes());\n    +\n    +cache = new TreeCache(client, \"/\", true);\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +\n    +Assert.assertTrue(cache.getCurrentChildren(\"/\").keySet().contains(\"test\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"one\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/one\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(new String(cache.getCurrentData(\"/test/one\").getData()), \"hey there\");\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testWithNamespace() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/outer\");\n    +client.create().forPath(\"/outer/foo\");\n    +client.create().forPath(\"/outer/test\");\n    +client.create().forPath(\"/outer/test/one\", \"hey there\".getBytes());\n    +\n    +cache = new TreeCache(client.usingNamespace(\"outer\"), \"/test\", true);\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"one\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/one\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(new String(cache.getCurrentData(\"/test/one\").getData()), \"hey there\");\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testWithNamespaceAtRoot() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/outer\");\n    +client.create().forPath(\"/outer/foo\");\n    +client.create().forPath(\"/outer/test\");\n    +client.create().forPath(\"/outer/test/one\", \"hey there\".getBytes());\n    +\n    +cache = new TreeCache(client.usingNamespace(\"outer\"), \"/\", true);\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/foo\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +Assert.assertEquals(cache.getCurrentChildren(\"/\").keySet(), ImmutableSet.of(\"foo\", \"test\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/foo\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"one\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/one\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(new String(cache.getCurrentData(\"/test/one\").getData()), \"hey there\");\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testSyncInitialPopulation() throws Exception<br/>\n    +    </p>\n{\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/one\", \"hey there\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testChildrenInitialized() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\", \"\".getBytes());\n    +client.create().forPath(\"/test/1\", \"1\".getBytes());\n    +client.create().forPath(\"/test/2\", \"2\".getBytes());\n    +client.create().forPath(\"/test/3\", \"3\".getBytes());\n    +\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/1\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/2\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/3\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testUpdateWhenNotCachingData() throws Exception<br/>\n    +    {<br/>\n    +client.create().forPath(\"/test\");<br/>\n    +<br/>\n    +cache = new TreeCache(client, \"/test\", false);<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Doesn't setup() already do this? Why is this second allocation needed?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695864/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695869","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695869","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695869,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4Njk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T15:13:38Z","updated_at":"2025-01-21T13:10:45Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15819016\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15819016</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/test/java/org/apache/curator/framework/recipes/cache/BaseTestTreeCache.java &#8212;<br/>\n    @@ -0,0 +1,173 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.CuratorFrameworkFactory;<br/>\n    +import org.apache.curator.framework.api.UnhandledErrorListener;<br/>\n    +import org.apache.curator.retry.RetryOneTime;<br/>\n    +import org.apache.curator.test.BaseClassForTests;<br/>\n    +import org.apache.curator.test.Timing;<br/>\n    +import org.apache.curator.utils.CloseableUtils;<br/>\n    +import org.testng.Assert;<br/>\n    +import org.testng.annotations.AfterMethod;<br/>\n    +import org.testng.annotations.BeforeMethod;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.List;<br/>\n    +import java.util.concurrent.BlockingQueue;<br/>\n    +import java.util.concurrent.LinkedBlockingQueue;<br/>\n    +import java.util.concurrent.TimeUnit;<br/>\n    +<br/>\n    +public class BaseTestTreeCache extends BaseClassForTests<br/>\n    +{<br/>\n    +    private final Timing timing = new Timing();<br/>\n    +    CuratorFramework client;<br/>\n    +    TreeCache cache;<br/>\n    +    private List<Throwable> exceptions;<br/>\n    +    private BlockingQueue<TreeCacheEvent> events;<br/>\n    +    TreeCacheListener eventListener;<br/>\n    +<br/>\n    +    /**<br/>\n    +     * A TreeCache that records exceptions and automatically adds a listener.<br/>\n    +     */<br/>\n    +    class TreeCache extends org.apache.curator.framework.recipes.cache.TreeCache<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Because the local class shadows it.  `class TreeCache extends TreeCache` would extend itself.  Arguably, I could rename the local class to \"MyTreeCache\" or something, if you guys think that's the better style.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695869/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695875","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695875","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695875,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4NzU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T15:14:32Z","updated_at":"2025-01-21T13:10:45Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15819107\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15819107</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/test/java/org/apache/curator/framework/recipes/cache/BaseTestTreeCache.java &#8212;<br/>\n    @@ -0,0 +1,173 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.CuratorFrameworkFactory;<br/>\n    +import org.apache.curator.framework.api.UnhandledErrorListener;<br/>\n    +import org.apache.curator.retry.RetryOneTime;<br/>\n    +import org.apache.curator.test.BaseClassForTests;<br/>\n    +import org.apache.curator.test.Timing;<br/>\n    +import org.apache.curator.utils.CloseableUtils;<br/>\n    +import org.testng.Assert;<br/>\n    +import org.testng.annotations.AfterMethod;<br/>\n    +import org.testng.annotations.BeforeMethod;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.List;<br/>\n    +import java.util.concurrent.BlockingQueue;<br/>\n    +import java.util.concurrent.LinkedBlockingQueue;<br/>\n    +import java.util.concurrent.TimeUnit;<br/>\n    +<br/>\n    +public class BaseTestTreeCache extends BaseClassForTests<br/>\n    +{<br/>\n    +    private final Timing timing = new Timing();<br/>\n    +    CuratorFramework client;<br/>\n    +    TreeCache cache;<br/>\n    +    private List<Throwable> exceptions;<br/>\n    +    private BlockingQueue<TreeCacheEvent> events;<br/>\n    +    TreeCacheListener eventListener;<br/>\n    +<br/>\n    +    /**<br/>\n    +     * A TreeCache that records exceptions and automatically adds a listener.<br/>\n    +     */<br/>\n    +    class TreeCache extends org.apache.curator.framework.recipes.cache.TreeCache<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    I'd rename it. It confused me.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695875/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695878","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695878","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695878,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4Nzg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T15:15:25Z","updated_at":"2025-01-21T13:10:45Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15819163\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15819163</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/test/java/org/apache/curator/framework/recipes/cache/TestTreeCache.java &#8212;<br/>\n    @@ -0,0 +1,335 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.collect.ImmutableSet;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.test.KillSession;<br/>\n    +import org.apache.curator.utils.CloseableUtils;<br/>\n    +import org.apache.zookeeper.CreateMode;<br/>\n    +import org.testng.Assert;<br/>\n    +import org.testng.annotations.Test;<br/>\n    +import java.util.concurrent.Semaphore;<br/>\n    +<br/>\n    +public class TestTreeCache extends BaseTestTreeCache<br/>\n    +{<br/>\n    +    @Test<br/>\n    +    public void testStartup() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/1\", \"one\".getBytes());\n    +client.create().forPath(\"/test/2\", \"two\".getBytes());\n    +client.create().forPath(\"/test/3\", \"three\".getBytes());\n    +client.create().forPath(\"/test/2/sub\", \"two-sub\".getBytes());\n    +\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/1\", \"one\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/2\", \"two\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/3\", \"three\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/2/sub\", \"two-sub\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"1\", \"2\", \"3\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/1\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/2\").keySet(), ImmutableSet.of(\"sub\"));\n    +Assert.assertNull(cache.getCurrentChildren(\"/test/non_exist\"));\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testStartEmpty() throws Exception<br/>\n    +    </p>\n{\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +\n    +client.create().forPath(\"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testAsyncInitialPopulation() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/one\", \"hey there\".getBytes());\n    +\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testFromRoot() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/one\", \"hey there\".getBytes());\n    +\n    +cache = new TreeCache(client, \"/\", true);\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +\n    +Assert.assertTrue(cache.getCurrentChildren(\"/\").keySet().contains(\"test\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"one\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/one\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(new String(cache.getCurrentData(\"/test/one\").getData()), \"hey there\");\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testWithNamespace() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/outer\");\n    +client.create().forPath(\"/outer/foo\");\n    +client.create().forPath(\"/outer/test\");\n    +client.create().forPath(\"/outer/test/one\", \"hey there\".getBytes());\n    +\n    +cache = new TreeCache(client.usingNamespace(\"outer\"), \"/test\", true);\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"one\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/one\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(new String(cache.getCurrentData(\"/test/one\").getData()), \"hey there\");\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testWithNamespaceAtRoot() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/outer\");\n    +client.create().forPath(\"/outer/foo\");\n    +client.create().forPath(\"/outer/test\");\n    +client.create().forPath(\"/outer/test/one\", \"hey there\".getBytes());\n    +\n    +cache = new TreeCache(client.usingNamespace(\"outer\"), \"/\", true);\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/foo\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +Assert.assertEquals(cache.getCurrentChildren(\"/\").keySet(), ImmutableSet.of(\"foo\", \"test\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/foo\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"one\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/one\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(new String(cache.getCurrentData(\"/test/one\").getData()), \"hey there\");\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testSyncInitialPopulation() throws Exception<br/>\n    +    </p>\n{\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/one\", \"hey there\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testChildrenInitialized() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\", \"\".getBytes());\n    +client.create().forPath(\"/test/1\", \"1\".getBytes());\n    +client.create().forPath(\"/test/2\", \"2\".getBytes());\n    +client.create().forPath(\"/test/3\", \"3\".getBytes());\n    +\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/1\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/2\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/3\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testUpdateWhenNotCachingData() throws Exception<br/>\n    +    {<br/>\n    +client.create().forPath(\"/test\");<br/>\n    +<br/>\n    +cache = new TreeCache(client, \"/test\", false);<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Many tests use the same set of default arguments (and use the existing object from setup), whereas this and a few other use different arguments.  e.g. this is the 'not caching' test so I have to create a new tree with 'false' for caching.  If it would be less confusing, I could just never initialize client in setup and move the initialization explicitly into every test.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695878/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695880","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695880","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695880,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4ODA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T15:16:19Z","updated_at":"2025-01-21T13:10:45Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15819222\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15819222</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/test/java/org/apache/curator/framework/recipes/cache/BaseTestTreeCache.java &#8212;<br/>\n    @@ -0,0 +1,173 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.CuratorFrameworkFactory;<br/>\n    +import org.apache.curator.framework.api.UnhandledErrorListener;<br/>\n    +import org.apache.curator.retry.RetryOneTime;<br/>\n    +import org.apache.curator.test.BaseClassForTests;<br/>\n    +import org.apache.curator.test.Timing;<br/>\n    +import org.apache.curator.utils.CloseableUtils;<br/>\n    +import org.testng.Assert;<br/>\n    +import org.testng.annotations.AfterMethod;<br/>\n    +import org.testng.annotations.BeforeMethod;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.List;<br/>\n    +import java.util.concurrent.BlockingQueue;<br/>\n    +import java.util.concurrent.LinkedBlockingQueue;<br/>\n    +import java.util.concurrent.TimeUnit;<br/>\n    +<br/>\n    +public class BaseTestTreeCache extends BaseClassForTests<br/>\n    +{<br/>\n    +    private final Timing timing = new Timing();<br/>\n    +    CuratorFramework client;<br/>\n    +    TreeCache cache;<br/>\n    +    private List<Throwable> exceptions;<br/>\n    +    private BlockingQueue<TreeCacheEvent> events;<br/>\n    +    TreeCacheListener eventListener;<br/>\n    +<br/>\n    +    /**<br/>\n    +     * A TreeCache that records exceptions and automatically adds a listener.<br/>\n    +     */<br/>\n    +    class TreeCache extends org.apache.curator.framework.recipes.cache.TreeCache<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    K.  Originally I was going to name it \"TestTreeCache\" but then realized it conflicted with the test of the same name.  I'll figure something out.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695880/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702717","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702717","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702717,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3MTc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T19:03:06Z","updated_at":"2025-01-21T13:13:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ortschun\">ortschun</a>:</i>\n<p>Sorry about that. I have updated the test above.</p>\n\n<p>The first run throws the interrupted exception. Test passes but data is not cleared.</p>\n\n<p>The second run gets in a deadlock.</p>\n\n<p>We're still hitting this in prod environment quite often.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702717/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695886","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695886","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695886,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4ODY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-05T22:19:39Z","updated_at":"2025-01-21T13:10:45Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15845904\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15845904</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }<br/>\n    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( isInitialized.compareAndSet(false, true) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Tracks the number of outstanding background requests in flight. The first time this count reaches 0, we publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Have we published the {@link TreeCacheEvent.Type#INITIALIZED} event yet?<br/>\n    +     */<br/>\n    +    private final AtomicBoolean isInitialized = new AtomicBoolean(false);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), \"already started\");\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache.<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close()<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    if ( root.path.length() > 1 )<br/>\n    +    {\n    +fullPath = fullPath.substring(root.path.length());\n    +    }<br/>\n    +    List<String> split = ZKPaths.split(fullPath);<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children at the given path, mapped by child name. There are no<br/>\n    +     * guarantees of accuracy; this is merely the most recent view of the data.  If there is no<br/>\n    +     * node at this path, {@code null} is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public Map<String, ChildData> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +Map<String, ChildData> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableMap.of();\n    +}\n<p>    +else<br/>\n    +{<br/>\n    +    ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();<br/>\n    +    for ( Map.Entry<String, TreeNode> entry : map.entrySet() )<br/>\n    +    {<br/>\n    +TreeNode childNode = entry.getValue();<br/>\n    +ChildData childData = new ChildData(childNode.path, childNode.stat.get(), childNode.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +if ( childNode.nodeState.get() == NodeState.LIVE )<br/>\n    +</p>\n{\n    +    builder.put(entry.getKey(), childData);\n    +}\n<p>    +    }<br/>\n    +    result = builder.build();<br/>\n    +}<br/>\n    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no node at the given path,<br/>\n    +     * </p>\n{@code null}\n<p> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    private void callListeners(final TreeCacheEvent event)<br/>\n    +    {<br/>\n    +listeners.forEach(new Function<TreeCacheListener, Void>()<br/>\n    +{<br/>\n    +    @Override<br/>\n    +    public Void apply(TreeCacheListener listener)<br/>\n    +    {<br/>\n    +try<br/>\n    +</p>\n{\n    +    listener.childEvent(client, event);\n    +}\n<p>    +catch ( Exception e )<br/>\n    +</p>\n{\n    +    handleException(e);\n    +}\n<p>    +return null;<br/>\n    +    }<br/>\n    +});<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Default behavior is just to log the exception<br/>\n    +     *<br/>\n    +     * @param e the exception<br/>\n    +     */<br/>\n    +    protected void handleException(Throwable e)<br/>\n    +    </p>\n{\n    +LOG.error(\"\", e);\n    +    }\n<p>    +<br/>\n    +    private void handleStateChange(ConnectionState newState)<br/>\n    +    {<br/>\n    +switch ( newState )<br/>\n    +{<br/>\n    +case SUSPENDED:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);<br/>\n    +    break;<br/>\n    +<br/>\n    +case LOST:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);<br/>\n    +    break;<br/>\n    +<br/>\n    +case RECONNECTED:<br/>\n    +    try<br/>\n    +    </p>\n{\n    +root.wasReconnected();\n    +publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);\n    +    }\n<p>    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +    break;<br/>\n    +}<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    There is an edge case that is not handled here. If the tree cache is started prior to a connection to ZooKeeper becoming available, then the state change will be CONNECTED rather than RECONNECTED. This means that the necessary watches don't get set up. The LeaderLatch recipe had a similar issue, which was solved by waiting until a connection was available (in the background) in start().</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695886/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695891","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695891","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695891,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4OTE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T02:02:18Z","updated_at":"2025-01-21T13:10:45Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15915313\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15915313</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/test/java/org/apache/curator/framework/recipes/cache/TestTreeCache.java &#8212;<br/>\n    @@ -0,0 +1,335 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.collect.ImmutableSet;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.test.KillSession;<br/>\n    +import org.apache.curator.utils.CloseableUtils;<br/>\n    +import org.apache.zookeeper.CreateMode;<br/>\n    +import org.testng.Assert;<br/>\n    +import org.testng.annotations.Test;<br/>\n    +import java.util.concurrent.Semaphore;<br/>\n    +<br/>\n    +public class TestTreeCache extends BaseTestTreeCache<br/>\n    +{<br/>\n    +    @Test<br/>\n    +    public void testStartup() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/1\", \"one\".getBytes());\n    +client.create().forPath(\"/test/2\", \"two\".getBytes());\n    +client.create().forPath(\"/test/3\", \"three\".getBytes());\n    +client.create().forPath(\"/test/2/sub\", \"two-sub\".getBytes());\n    +\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/1\", \"one\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/2\", \"two\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/3\", \"three\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/2/sub\", \"two-sub\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"1\", \"2\", \"3\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/1\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/2\").keySet(), ImmutableSet.of(\"sub\"));\n    +Assert.assertNull(cache.getCurrentChildren(\"/test/non_exist\"));\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testStartEmpty() throws Exception<br/>\n    +    </p>\n{\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +\n    +client.create().forPath(\"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testAsyncInitialPopulation() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/one\", \"hey there\".getBytes());\n    +\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testFromRoot() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/one\", \"hey there\".getBytes());\n    +\n    +cache = new TreeCache(client, \"/\", true);\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +\n    +Assert.assertTrue(cache.getCurrentChildren(\"/\").keySet().contains(\"test\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"one\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/one\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(new String(cache.getCurrentData(\"/test/one\").getData()), \"hey there\");\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testWithNamespace() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/outer\");\n    +client.create().forPath(\"/outer/foo\");\n    +client.create().forPath(\"/outer/test\");\n    +client.create().forPath(\"/outer/test/one\", \"hey there\".getBytes());\n    +\n    +cache = new TreeCache(client.usingNamespace(\"outer\"), \"/test\", true);\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"one\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/one\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(new String(cache.getCurrentData(\"/test/one\").getData()), \"hey there\");\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testWithNamespaceAtRoot() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/outer\");\n    +client.create().forPath(\"/outer/foo\");\n    +client.create().forPath(\"/outer/test\");\n    +client.create().forPath(\"/outer/test/one\", \"hey there\".getBytes());\n    +\n    +cache = new TreeCache(client.usingNamespace(\"outer\"), \"/\", true);\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/foo\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +Assert.assertEquals(cache.getCurrentChildren(\"/\").keySet(), ImmutableSet.of(\"foo\", \"test\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/foo\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test\").keySet(), ImmutableSet.of(\"one\"));\n    +Assert.assertEquals(cache.getCurrentChildren(\"/test/one\").keySet(), ImmutableSet.of());\n    +Assert.assertEquals(new String(cache.getCurrentData(\"/test/one\").getData()), \"hey there\");\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testSyncInitialPopulation() throws Exception<br/>\n    +    </p>\n{\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +\n    +client.create().forPath(\"/test\");\n    +client.create().forPath(\"/test/one\", \"hey there\".getBytes());\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/one\");\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testChildrenInitialized() throws Exception<br/>\n    +    </p>\n{\n    +client.create().forPath(\"/test\", \"\".getBytes());\n    +client.create().forPath(\"/test/1\", \"1\".getBytes());\n    +client.create().forPath(\"/test/2\", \"2\".getBytes());\n    +client.create().forPath(\"/test/3\", \"3\".getBytes());\n    +\n    +cache.start();\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/1\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/2\");\n    +assertEvent(TreeCacheEvent.Type.NODE_ADDED, \"/test/3\");\n    +assertEvent(TreeCacheEvent.Type.INITIALIZED);\n    +assertNoMoreEvents();\n    +    }\n<p>    +<br/>\n    +    @Test<br/>\n    +    public void testUpdateWhenNotCachingData() throws Exception<br/>\n    +    {<br/>\n    +client.create().forPath(\"/test\");<br/>\n    +<br/>\n    +cache = new TreeCache(client, \"/test\", false);<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Fixed to never initialize client for less confusion.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695891/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695900","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695900","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695900,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5MDA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T02:03:36Z","updated_at":"2025-01-21T13:10:45Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15915346\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15915346</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCacheEvent.java &#8212;<br/>\n    @@ -0,0 +1,126 @@<br/>\n    +/**<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Ok.  What do you think if I rename these to CacheEvent / CacheListener for now, and then after this lands, go back separately and add the new listener APIs to NodeCache and PathChildrenCache?  Or does it need to be 100% done in one shot?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695900/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695909","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695909","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695909,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5MDk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T02:04:54Z","updated_at":"2025-01-21T13:10:45Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15915372\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15915372</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +</p>\n{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}\n<p>    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}\n<p>    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    </p>\n{\n    +data.set(event.getData());\n    +    }\n<p>    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +</p>\n{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}\n<p>    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Please add a break</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695909/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695917","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695917","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695917,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5MTc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T02:05:53Z","updated_at":"2025-01-21T13:10:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15915401\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15915401</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +</p>\n{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}\n<p>    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}\n<p>    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    </p>\n{\n    +data.set(event.getData());\n    +    }\n<p>    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +</p>\n{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}\n<p>    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    I'm not certain it's ideal to log these are errors. Curator will log any connection issues, etc. This might create a lot of noise.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695917/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695924","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695924","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695924,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5MjQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T02:31:58Z","updated_at":"2025-01-21T13:10:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>At some point in the future, we might consider deprecating PathChildrenCache or replacing it's implementation with a contained TreeCache.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695924/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695930","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695930","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695930,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5MzA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T03:52:41Z","updated_at":"2025-01-21T13:10:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15917501\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15917501</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }<br/>\n    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( isInitialized.compareAndSet(false, true) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Tracks the number of outstanding background requests in flight. The first time this count reaches 0, we publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Have we published the {@link TreeCacheEvent.Type#INITIALIZED} event yet?<br/>\n    +     */<br/>\n    +    private final AtomicBoolean isInitialized = new AtomicBoolean(false);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), \"already started\");\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache.<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close()<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    if ( root.path.length() > 1 )<br/>\n    +    {\n    +fullPath = fullPath.substring(root.path.length());\n    +    }<br/>\n    +    List<String> split = ZKPaths.split(fullPath);<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children at the given path, mapped by child name. There are no<br/>\n    +     * guarantees of accuracy; this is merely the most recent view of the data.  If there is no<br/>\n    +     * node at this path, {@code null} is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public Map<String, ChildData> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +Map<String, ChildData> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableMap.of();\n    +}\n<p>    +else<br/>\n    +{<br/>\n    +    ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();<br/>\n    +    for ( Map.Entry<String, TreeNode> entry : map.entrySet() )<br/>\n    +    {<br/>\n    +TreeNode childNode = entry.getValue();<br/>\n    +ChildData childData = new ChildData(childNode.path, childNode.stat.get(), childNode.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +if ( childNode.nodeState.get() == NodeState.LIVE )<br/>\n    +</p>\n{\n    +    builder.put(entry.getKey(), childData);\n    +}\n<p>    +    }<br/>\n    +    result = builder.build();<br/>\n    +}<br/>\n    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no node at the given path,<br/>\n    +     * </p>\n{@code null}\n<p> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    private void callListeners(final TreeCacheEvent event)<br/>\n    +    {<br/>\n    +listeners.forEach(new Function<TreeCacheListener, Void>()<br/>\n    +{<br/>\n    +    @Override<br/>\n    +    public Void apply(TreeCacheListener listener)<br/>\n    +    {<br/>\n    +try<br/>\n    +</p>\n{\n    +    listener.childEvent(client, event);\n    +}\n<p>    +catch ( Exception e )<br/>\n    +</p>\n{\n    +    handleException(e);\n    +}\n<p>    +return null;<br/>\n    +    }<br/>\n    +});<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Default behavior is just to log the exception<br/>\n    +     *<br/>\n    +     * @param e the exception<br/>\n    +     */<br/>\n    +    protected void handleException(Throwable e)<br/>\n    +    </p>\n{\n    +LOG.error(\"\", e);\n    +    }\n<p>    +<br/>\n    +    private void handleStateChange(ConnectionState newState)<br/>\n    +    {<br/>\n    +switch ( newState )<br/>\n    +{<br/>\n    +case SUSPENDED:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);<br/>\n    +    break;<br/>\n    +<br/>\n    +case LOST:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);<br/>\n    +    break;<br/>\n    +<br/>\n    +case RECONNECTED:<br/>\n    +    try<br/>\n    +    </p>\n{\n    +root.wasReconnected();\n    +publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);\n    +    }\n<p>    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +    break;<br/>\n    +}<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Good catch.  Any idea how to test this?  I can add the case here but would be nice to test.</p>\n\n<p>    Also: should I do something like this in start()?</p>\n\n<p>    ```<br/>\n    if (client.getZookeeperClient().isConnected())</p>\n    {\nroot.wasCreated();\n    }\n<p>    ```</p>\n\n<p>    Or is this not needed?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695930/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695939","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695939","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695939,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5Mzk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T03:55:29Z","updated_at":"2025-01-21T13:10:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15917546\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15917546</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +</p>\n{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}\n<p>    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}\n<p>    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    </p>\n{\n    +data.set(event.getData());\n    +    }\n<p>    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +</p>\n{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}\n<p>    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    added a break.  this is just a standard switch-on-enum where you provide a case for all known enum members and then default to throwing an exception.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695939/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695947","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695947","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695947,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5NDc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T03:58:48Z","updated_at":"2025-01-21T13:10:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15917583\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15917583</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }<br/>\n    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( isInitialized.compareAndSet(false, true) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Tracks the number of outstanding background requests in flight. The first time this count reaches 0, we publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Have we published the {@link TreeCacheEvent.Type#INITIALIZED} event yet?<br/>\n    +     */<br/>\n    +    private final AtomicBoolean isInitialized = new AtomicBoolean(false);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), \"already started\");\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache.<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close()<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    if ( root.path.length() > 1 )<br/>\n    +    {\n    +fullPath = fullPath.substring(root.path.length());\n    +    }<br/>\n    +    List<String> split = ZKPaths.split(fullPath);<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children at the given path, mapped by child name. There are no<br/>\n    +     * guarantees of accuracy; this is merely the most recent view of the data.  If there is no<br/>\n    +     * node at this path, {@code null} is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public Map<String, ChildData> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +Map<String, ChildData> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableMap.of();\n    +}\n<p>    +else<br/>\n    +{<br/>\n    +    ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();<br/>\n    +    for ( Map.Entry<String, TreeNode> entry : map.entrySet() )<br/>\n    +    {<br/>\n    +TreeNode childNode = entry.getValue();<br/>\n    +ChildData childData = new ChildData(childNode.path, childNode.stat.get(), childNode.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +if ( childNode.nodeState.get() == NodeState.LIVE )<br/>\n    +</p>\n{\n    +    builder.put(entry.getKey(), childData);\n    +}\n<p>    +    }<br/>\n    +    result = builder.build();<br/>\n    +}<br/>\n    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no node at the given path,<br/>\n    +     * </p>\n{@code null}\n<p> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    private void callListeners(final TreeCacheEvent event)<br/>\n    +    {<br/>\n    +listeners.forEach(new Function<TreeCacheListener, Void>()<br/>\n    +{<br/>\n    +    @Override<br/>\n    +    public Void apply(TreeCacheListener listener)<br/>\n    +    {<br/>\n    +try<br/>\n    +</p>\n{\n    +    listener.childEvent(client, event);\n    +}\n<p>    +catch ( Exception e )<br/>\n    +</p>\n{\n    +    handleException(e);\n    +}\n<p>    +return null;<br/>\n    +    }<br/>\n    +});<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Default behavior is just to log the exception<br/>\n    +     *<br/>\n    +     * @param e the exception<br/>\n    +     */<br/>\n    +    protected void handleException(Throwable e)<br/>\n    +    </p>\n{\n    +LOG.error(\"\", e);\n    +    }\n<p>    +<br/>\n    +    private void handleStateChange(ConnectionState newState)<br/>\n    +    {<br/>\n    +switch ( newState )<br/>\n    +{<br/>\n    +case SUSPENDED:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);<br/>\n    +    break;<br/>\n    +<br/>\n    +case LOST:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);<br/>\n    +    break;<br/>\n    +<br/>\n    +case RECONNECTED:<br/>\n    +    try<br/>\n    +    </p>\n{\n    +root.wasReconnected();\n    +publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);\n    +    }\n<p>    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +    break;<br/>\n    +}<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    To test it, just start the curator framework and the TreeCache, but don't start the testing server. Then start the testing server. The tree cache will get a CONNECTED event, and nothing will happen. If you then stop the server and start it again, the cache will start working because it gets a reconnected event.</p>\n\n<p>    To get the error you need to make sure that all retries have been exhausted prior to starting the test server.</p>\n\n<p>    To actually put an assertion into the test case, I guess you'll just need to make it time based. I.e. Assert that you get an initialised event from the TreeCache within 5 seconds of the server starting</p>\n\n<p>    As for the start() method, what you're suggesting should work, assuming you add something to handle the CONNECTED state in the listener. Alternatively, look at how its done in LeaderLatch.</p>\n\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695947/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695953","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695953","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695953,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5NTM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T04:07:21Z","updated_at":"2025-01-21T13:10:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15917752\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15917752</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }<br/>\n    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( isInitialized.compareAndSet(false, true) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Tracks the number of outstanding background requests in flight. The first time this count reaches 0, we publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Have we published the {@link TreeCacheEvent.Type#INITIALIZED} event yet?<br/>\n    +     */<br/>\n    +    private final AtomicBoolean isInitialized = new AtomicBoolean(false);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), \"already started\");\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache.<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close()<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    if ( root.path.length() > 1 )<br/>\n    +    {\n    +fullPath = fullPath.substring(root.path.length());\n    +    }<br/>\n    +    List<String> split = ZKPaths.split(fullPath);<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children at the given path, mapped by child name. There are no<br/>\n    +     * guarantees of accuracy; this is merely the most recent view of the data.  If there is no<br/>\n    +     * node at this path, {@code null} is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public Map<String, ChildData> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +Map<String, ChildData> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableMap.of();\n    +}\n<p>    +else<br/>\n    +{<br/>\n    +    ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();<br/>\n    +    for ( Map.Entry<String, TreeNode> entry : map.entrySet() )<br/>\n    +    {<br/>\n    +TreeNode childNode = entry.getValue();<br/>\n    +ChildData childData = new ChildData(childNode.path, childNode.stat.get(), childNode.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +if ( childNode.nodeState.get() == NodeState.LIVE )<br/>\n    +</p>\n{\n    +    builder.put(entry.getKey(), childData);\n    +}\n<p>    +    }<br/>\n    +    result = builder.build();<br/>\n    +}<br/>\n    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no node at the given path,<br/>\n    +     * </p>\n{@code null}\n<p> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    private void callListeners(final TreeCacheEvent event)<br/>\n    +    {<br/>\n    +listeners.forEach(new Function<TreeCacheListener, Void>()<br/>\n    +{<br/>\n    +    @Override<br/>\n    +    public Void apply(TreeCacheListener listener)<br/>\n    +    {<br/>\n    +try<br/>\n    +</p>\n{\n    +    listener.childEvent(client, event);\n    +}\n<p>    +catch ( Exception e )<br/>\n    +</p>\n{\n    +    handleException(e);\n    +}\n<p>    +return null;<br/>\n    +    }<br/>\n    +});<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Default behavior is just to log the exception<br/>\n    +     *<br/>\n    +     * @param e the exception<br/>\n    +     */<br/>\n    +    protected void handleException(Throwable e)<br/>\n    +    </p>\n{\n    +LOG.error(\"\", e);\n    +    }\n<p>    +<br/>\n    +    private void handleStateChange(ConnectionState newState)<br/>\n    +    {<br/>\n    +switch ( newState )<br/>\n    +{<br/>\n    +case SUSPENDED:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);<br/>\n    +    break;<br/>\n    +<br/>\n    +case LOST:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);<br/>\n    +    break;<br/>\n    +<br/>\n    +case RECONNECTED:<br/>\n    +    try<br/>\n    +    </p>\n{\n    +root.wasReconnected();\n    +publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);\n    +    }\n<p>    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +    break;<br/>\n    +}<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Thanks!  Super helpful.  I'll test this out.  I'm loathe to leave a thread blocked for no good reason though when I already have a connection state listener, so I'll probably just do it that way.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695953/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695962","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695962","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695962,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5NjI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T04:15:31Z","updated_at":"2025-01-21T13:10:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15917910\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15917910</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }<br/>\n    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( isInitialized.compareAndSet(false, true) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Tracks the number of outstanding background requests in flight. The first time this count reaches 0, we publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Have we published the {@link TreeCacheEvent.Type#INITIALIZED} event yet?<br/>\n    +     */<br/>\n    +    private final AtomicBoolean isInitialized = new AtomicBoolean(false);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), \"already started\");\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache.<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close()<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    if ( root.path.length() > 1 )<br/>\n    +    {\n    +fullPath = fullPath.substring(root.path.length());\n    +    }<br/>\n    +    List<String> split = ZKPaths.split(fullPath);<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children at the given path, mapped by child name. There are no<br/>\n    +     * guarantees of accuracy; this is merely the most recent view of the data.  If there is no<br/>\n    +     * node at this path, {@code null} is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public Map<String, ChildData> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +Map<String, ChildData> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableMap.of();\n    +}\n<p>    +else<br/>\n    +{<br/>\n    +    ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();<br/>\n    +    for ( Map.Entry<String, TreeNode> entry : map.entrySet() )<br/>\n    +    {<br/>\n    +TreeNode childNode = entry.getValue();<br/>\n    +ChildData childData = new ChildData(childNode.path, childNode.stat.get(), childNode.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +if ( childNode.nodeState.get() == NodeState.LIVE )<br/>\n    +</p>\n{\n    +    builder.put(entry.getKey(), childData);\n    +}\n<p>    +    }<br/>\n    +    result = builder.build();<br/>\n    +}<br/>\n    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no node at the given path,<br/>\n    +     * </p>\n{@code null}\n<p> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    private void callListeners(final TreeCacheEvent event)<br/>\n    +    {<br/>\n    +listeners.forEach(new Function<TreeCacheListener, Void>()<br/>\n    +{<br/>\n    +    @Override<br/>\n    +    public Void apply(TreeCacheListener listener)<br/>\n    +    {<br/>\n    +try<br/>\n    +</p>\n{\n    +    listener.childEvent(client, event);\n    +}\n<p>    +catch ( Exception e )<br/>\n    +</p>\n{\n    +    handleException(e);\n    +}\n<p>    +return null;<br/>\n    +    }<br/>\n    +});<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Default behavior is just to log the exception<br/>\n    +     *<br/>\n    +     * @param e the exception<br/>\n    +     */<br/>\n    +    protected void handleException(Throwable e)<br/>\n    +    </p>\n{\n    +LOG.error(\"\", e);\n    +    }\n<p>    +<br/>\n    +    private void handleStateChange(ConnectionState newState)<br/>\n    +    {<br/>\n    +switch ( newState )<br/>\n    +{<br/>\n    +case SUSPENDED:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);<br/>\n    +    break;<br/>\n    +<br/>\n    +case LOST:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);<br/>\n    +    break;<br/>\n    +<br/>\n    +case RECONNECTED:<br/>\n    +    try<br/>\n    +    </p>\n{\n    +root.wasReconnected();\n    +publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);\n    +    }\n<p>    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +    break;<br/>\n    +}<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    I think the reason that we went with the thread approach rather than handling the CONNECTED event was that it avoids a potential race condition. If start() gets called on the TreeCache and the same time as the tree cache is receiving a CONNECTED event, it's possible for the wasCreated() method to be called twice.</p>\n\n<p>    For LeaderLatch, this was an issue because it would toggle the elected state (i.e leader, not leader, leader) in quick succession. For the TreeCache cache, it will just mean that refresh will get called twice. I'm not sure if having two refreshes running at the same time will cause any concurrency issues?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695962/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702721","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702721","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702721,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3MjE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T06:11:49Z","updated_at":"2025-01-21T13:13:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cammckenzie\">cammckenzie</a>:</i>\n<p>If you run this test twice, won't the second time have a different session? So, presumably you wouldn't get a deadlock, but on the second run, it would block until the session of the first client expired? Or am I missing something?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702721/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702729","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702729","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702729,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3Mjk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T06:45:16Z","updated_at":"2025-01-21T13:13:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cammckenzie\">cammckenzie</a>:</i>\n<p>I've made some changes to the unit test and can reproduce the problem. Will look into a fix. I guess that we probably want to either query to see if the node is actually there, or just do a delete to remove it if it is in the case where we get an exception while trying to create the lock node. Will have a think about it.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702729/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702737","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702737","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702737,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3Mzc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T06:53:29Z","updated_at":"2025-01-21T13:13:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ortschun\">ortschun</a>:</i>\n<p>Thanks a lot for looking into it and I'm glad we have a repro. Could you share the final unit test you have, just for my curiosity.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702737/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702744","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702744","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702744,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3NDQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T07:32:19Z","updated_at":"2025-01-21T13:13:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cammckenzie\">cammckenzie</a>:</i>\n<p>I will certainly upload with a fix. It's a bit involved as it requires exposing the debugUnhandleExceptionListener on the CuratorFrameworkImpl to be able to interrupt the lock thread at the right time.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702744/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695967","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695967","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695967,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5Njc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T19:56:25Z","updated_at":"2025-01-21T13:10:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15959716\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15959716</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }<br/>\n    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( isInitialized.compareAndSet(false, true) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Tracks the number of outstanding background requests in flight. The first time this count reaches 0, we publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Have we published the {@link TreeCacheEvent.Type#INITIALIZED} event yet?<br/>\n    +     */<br/>\n    +    private final AtomicBoolean isInitialized = new AtomicBoolean(false);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), \"already started\");\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache.<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close()<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    if ( root.path.length() > 1 )<br/>\n    +    {\n    +fullPath = fullPath.substring(root.path.length());\n    +    }<br/>\n    +    List<String> split = ZKPaths.split(fullPath);<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children at the given path, mapped by child name. There are no<br/>\n    +     * guarantees of accuracy; this is merely the most recent view of the data.  If there is no<br/>\n    +     * node at this path, {@code null} is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public Map<String, ChildData> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +Map<String, ChildData> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableMap.of();\n    +}\n<p>    +else<br/>\n    +{<br/>\n    +    ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();<br/>\n    +    for ( Map.Entry<String, TreeNode> entry : map.entrySet() )<br/>\n    +    {<br/>\n    +TreeNode childNode = entry.getValue();<br/>\n    +ChildData childData = new ChildData(childNode.path, childNode.stat.get(), childNode.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +if ( childNode.nodeState.get() == NodeState.LIVE )<br/>\n    +</p>\n{\n    +    builder.put(entry.getKey(), childData);\n    +}\n<p>    +    }<br/>\n    +    result = builder.build();<br/>\n    +}<br/>\n    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no node at the given path,<br/>\n    +     * </p>\n{@code null}\n<p> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    private void callListeners(final TreeCacheEvent event)<br/>\n    +    {<br/>\n    +listeners.forEach(new Function<TreeCacheListener, Void>()<br/>\n    +{<br/>\n    +    @Override<br/>\n    +    public Void apply(TreeCacheListener listener)<br/>\n    +    {<br/>\n    +try<br/>\n    +</p>\n{\n    +    listener.childEvent(client, event);\n    +}\n<p>    +catch ( Exception e )<br/>\n    +</p>\n{\n    +    handleException(e);\n    +}\n<p>    +return null;<br/>\n    +    }<br/>\n    +});<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Default behavior is just to log the exception<br/>\n    +     *<br/>\n    +     * @param e the exception<br/>\n    +     */<br/>\n    +    protected void handleException(Throwable e)<br/>\n    +    </p>\n{\n    +LOG.error(\"\", e);\n    +    }\n<p>    +<br/>\n    +    private void handleStateChange(ConnectionState newState)<br/>\n    +    {<br/>\n    +switch ( newState )<br/>\n    +{<br/>\n    +case SUSPENDED:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);<br/>\n    +    break;<br/>\n    +<br/>\n    +case LOST:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);<br/>\n    +    break;<br/>\n    +<br/>\n    +case RECONNECTED:<br/>\n    +    try<br/>\n    +    </p>\n{\n    +root.wasReconnected();\n    +publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);\n    +    }\n<p>    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +    break;<br/>\n    +}<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Excellent info, that makes complete sense.  I tested this out two ways:</p>\n\n<p>    1) Call 'root.wasCreated()' twice sequentiall during start().<br/>\n    2) Same thing but put the first call on a new Thread to run concurrently.</p>\n\n<p>    All the tests passed, so I think the simple approach works here.  I believe it works because I'm using the compare-and-set style approach consistently throughout &#8211; for example if two threads are trying to concurrently add a new node \"/test/foo\" to an existing node \"/test\", only one thread can win; so duplicate events inherently don't propagate down the tree.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695967/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695971","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695971","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695971,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5NzE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T19:57:17Z","updated_at":"2025-01-21T13:10:47Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15959752\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15959752</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }<br/>\n    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( isInitialized.compareAndSet(false, true) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Tracks the number of outstanding background requests in flight. The first time this count reaches 0, we publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Have we published the {@link TreeCacheEvent.Type#INITIALIZED} event yet?<br/>\n    +     */<br/>\n    +    private final AtomicBoolean isInitialized = new AtomicBoolean(false);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), \"already started\");\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache.<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close()<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    if ( root.path.length() > 1 )<br/>\n    +    {\n    +fullPath = fullPath.substring(root.path.length());\n    +    }<br/>\n    +    List<String> split = ZKPaths.split(fullPath);<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children at the given path, mapped by child name. There are no<br/>\n    +     * guarantees of accuracy; this is merely the most recent view of the data.  If there is no<br/>\n    +     * node at this path, {@code null} is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public Map<String, ChildData> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +Map<String, ChildData> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableMap.of();\n    +}\n<p>    +else<br/>\n    +{<br/>\n    +    ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();<br/>\n    +    for ( Map.Entry<String, TreeNode> entry : map.entrySet() )<br/>\n    +    {<br/>\n    +TreeNode childNode = entry.getValue();<br/>\n    +ChildData childData = new ChildData(childNode.path, childNode.stat.get(), childNode.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +if ( childNode.nodeState.get() == NodeState.LIVE )<br/>\n    +</p>\n{\n    +    builder.put(entry.getKey(), childData);\n    +}\n<p>    +    }<br/>\n    +    result = builder.build();<br/>\n    +}<br/>\n    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no node at the given path,<br/>\n    +     * </p>\n{@code null}\n<p> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    private void callListeners(final TreeCacheEvent event)<br/>\n    +    {<br/>\n    +listeners.forEach(new Function<TreeCacheListener, Void>()<br/>\n    +{<br/>\n    +    @Override<br/>\n    +    public Void apply(TreeCacheListener listener)<br/>\n    +    {<br/>\n    +try<br/>\n    +</p>\n{\n    +    listener.childEvent(client, event);\n    +}\n<p>    +catch ( Exception e )<br/>\n    +</p>\n{\n    +    handleException(e);\n    +}\n<p>    +return null;<br/>\n    +    }<br/>\n    +});<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Default behavior is just to log the exception<br/>\n    +     *<br/>\n    +     * @param e the exception<br/>\n    +     */<br/>\n    +    protected void handleException(Throwable e)<br/>\n    +    </p>\n{\n    +LOG.error(\"\", e);\n    +    }\n<p>    +<br/>\n    +    private void handleStateChange(ConnectionState newState)<br/>\n    +    {<br/>\n    +switch ( newState )<br/>\n    +{<br/>\n    +case SUSPENDED:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);<br/>\n    +    break;<br/>\n    +<br/>\n    +case LOST:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);<br/>\n    +    break;<br/>\n    +<br/>\n    +case RECONNECTED:<br/>\n    +    try<br/>\n    +    </p>\n{\n    +root.wasReconnected();\n    +publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);\n    +    }\n<p>    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +    break;<br/>\n    +}<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Pushed a commit to solve the startup race and add the test you suggested.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695971/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695977","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695977","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695977,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5Nzc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T21:54:36Z","updated_at":"2025-01-21T13:10:47Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15966979\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15966979</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }<br/>\n    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( isInitialized.compareAndSet(false, true) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Tracks the number of outstanding background requests in flight. The first time this count reaches 0, we publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Have we published the {@link TreeCacheEvent.Type#INITIALIZED} event yet?<br/>\n    +     */<br/>\n    +    private final AtomicBoolean isInitialized = new AtomicBoolean(false);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), \"already started\");\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache.<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close()<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    if ( root.path.length() > 1 )<br/>\n    +    {\n    +fullPath = fullPath.substring(root.path.length());\n    +    }<br/>\n    +    List<String> split = ZKPaths.split(fullPath);<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children at the given path, mapped by child name. There are no<br/>\n    +     * guarantees of accuracy; this is merely the most recent view of the data.  If there is no<br/>\n    +     * node at this path, {@code null} is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public Map<String, ChildData> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +Map<String, ChildData> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableMap.of();\n    +}\n<p>    +else<br/>\n    +{<br/>\n    +    ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();<br/>\n    +    for ( Map.Entry<String, TreeNode> entry : map.entrySet() )<br/>\n    +    {<br/>\n    +TreeNode childNode = entry.getValue();<br/>\n    +ChildData childData = new ChildData(childNode.path, childNode.stat.get(), childNode.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +if ( childNode.nodeState.get() == NodeState.LIVE )<br/>\n    +</p>\n{\n    +    builder.put(entry.getKey(), childData);\n    +}\n<p>    +    }<br/>\n    +    result = builder.build();<br/>\n    +}<br/>\n    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no node at the given path,<br/>\n    +     * </p>\n{@code null}\n<p> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    private void callListeners(final TreeCacheEvent event)<br/>\n    +    {<br/>\n    +listeners.forEach(new Function<TreeCacheListener, Void>()<br/>\n    +{<br/>\n    +    @Override<br/>\n    +    public Void apply(TreeCacheListener listener)<br/>\n    +    {<br/>\n    +try<br/>\n    +</p>\n{\n    +    listener.childEvent(client, event);\n    +}\n<p>    +catch ( Exception e )<br/>\n    +</p>\n{\n    +    handleException(e);\n    +}\n<p>    +return null;<br/>\n    +    }<br/>\n    +});<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Default behavior is just to log the exception<br/>\n    +     *<br/>\n    +     * @param e the exception<br/>\n    +     */<br/>\n    +    protected void handleException(Throwable e)<br/>\n    +    </p>\n{\n    +LOG.error(\"\", e);\n    +    }\n<p>    +<br/>\n    +    private void handleStateChange(ConnectionState newState)<br/>\n    +    {<br/>\n    +switch ( newState )<br/>\n    +{<br/>\n    +case SUSPENDED:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);<br/>\n    +    break;<br/>\n    +<br/>\n    +case LOST:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);<br/>\n    +    break;<br/>\n    +<br/>\n    +case RECONNECTED:<br/>\n    +    try<br/>\n    +    </p>\n{\n    +root.wasReconnected();\n    +publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);\n    +    }\n<p>    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +    break;<br/>\n    +}<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    My only concern is efficiency issues caused by this race condition. If the TreeCache was being used on a large subtree, the initialising it twice is expensive. Using the approach in LeaderLatch guarantees that initialisation will only occur once.</p>\n\n<p>    Having said that, I'm not sure how likely this condition is to occur.</p>\n\n<p>    Other than that, all looks good to me.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695977/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695984","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695984","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695984,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5ODQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-07T23:23:51Z","updated_at":"2025-01-21T13:10:47Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15970735\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15970735</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }<br/>\n    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( isInitialized.compareAndSet(false, true) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Tracks the number of outstanding background requests in flight. The first time this count reaches 0, we publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Have we published the {@link TreeCacheEvent.Type#INITIALIZED} event yet?<br/>\n    +     */<br/>\n    +    private final AtomicBoolean isInitialized = new AtomicBoolean(false);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), \"already started\");\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache.<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close()<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    if ( root.path.length() > 1 )<br/>\n    +    {\n    +fullPath = fullPath.substring(root.path.length());\n    +    }<br/>\n    +    List<String> split = ZKPaths.split(fullPath);<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children at the given path, mapped by child name. There are no<br/>\n    +     * guarantees of accuracy; this is merely the most recent view of the data.  If there is no<br/>\n    +     * node at this path, {@code null} is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public Map<String, ChildData> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +Map<String, ChildData> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableMap.of();\n    +}\n<p>    +else<br/>\n    +{<br/>\n    +    ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();<br/>\n    +    for ( Map.Entry<String, TreeNode> entry : map.entrySet() )<br/>\n    +    {<br/>\n    +TreeNode childNode = entry.getValue();<br/>\n    +ChildData childData = new ChildData(childNode.path, childNode.stat.get(), childNode.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +if ( childNode.nodeState.get() == NodeState.LIVE )<br/>\n    +</p>\n{\n    +    builder.put(entry.getKey(), childData);\n    +}\n<p>    +    }<br/>\n    +    result = builder.build();<br/>\n    +}<br/>\n    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no node at the given path,<br/>\n    +     * </p>\n{@code null}\n<p> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    private void callListeners(final TreeCacheEvent event)<br/>\n    +    {<br/>\n    +listeners.forEach(new Function<TreeCacheListener, Void>()<br/>\n    +{<br/>\n    +    @Override<br/>\n    +    public Void apply(TreeCacheListener listener)<br/>\n    +    {<br/>\n    +try<br/>\n    +</p>\n{\n    +    listener.childEvent(client, event);\n    +}\n<p>    +catch ( Exception e )<br/>\n    +</p>\n{\n    +    handleException(e);\n    +}\n<p>    +return null;<br/>\n    +    }<br/>\n    +});<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Default behavior is just to log the exception<br/>\n    +     *<br/>\n    +     * @param e the exception<br/>\n    +     */<br/>\n    +    protected void handleException(Throwable e)<br/>\n    +    </p>\n{\n    +LOG.error(\"\", e);\n    +    }\n<p>    +<br/>\n    +    private void handleStateChange(ConnectionState newState)<br/>\n    +    {<br/>\n    +switch ( newState )<br/>\n    +{<br/>\n    +case SUSPENDED:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);<br/>\n    +    break;<br/>\n    +<br/>\n    +case LOST:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);<br/>\n    +    break;<br/>\n    +<br/>\n    +case RECONNECTED:<br/>\n    +    try<br/>\n    +    </p>\n{\n    +root.wasReconnected();\n    +publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);\n    +    }\n<p>    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +    break;<br/>\n    +}<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    In such a case, it won't actually initialize the entire tree twice, only the root node itself.  That's what I was trying to get at in my earlier comment: \"if two threads are trying to concurrently add a new node \"/test/foo\" to an existing node \"/test\", only one thread can win; so duplicate events inherently don't propagate down the tree\".  In other words, only one thread will actually do the recursive fetch on '/test/foo' and continue exploring that subtree.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695984/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695991","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695991","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695991,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5OTE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T01:07:09Z","updated_at":"2025-01-21T13:10:47Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15974091\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15974091</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,648 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.base.Preconditions;<br/>\n    +import com.google.common.collect.ImmutableMap;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.Map;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicBoolean;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    private final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +final TreeNode parent;<br/>\n    +final String path;<br/>\n    +final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refresh() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.addAndGet(2);\n    +    doRefreshData();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshChildren();\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    doRefreshData();\n    +}\n<p>    +<br/>\n    +private void doRefreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void doRefreshData() throws Exception<br/>\n    +{<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refresh();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refresh();\n    +}\n<p>    +<br/>\n    +void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    Preconditions.checkState(parent == null, \"unexpected NodeCreated on non-root node\");\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    Stat newStat = event.getStat();<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +Preconditions.checkState(parent == null, \"unexpected EXISTS on non-root node\");<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.get();<br/>\n    +    if (oldStat != null && oldStat.getMzxid() == newStat.getMzxid()) {\n    +// Only update stat if mzxid is different, otherwise we might obscure\n    +// GET_DATA event updates.\n    +stat.set(newStat);\n    +    }<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    Stat oldStat = stat.getAndSet(newStat);<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), newStat, event.getData()));\n    +    }<br/>\n    +    else<br/>\n    +    {<br/>\n    +if ( oldStat == null || oldStat.getMzxid() != newStat.getMzxid() )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), newStat, event.getData()));\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( isInitialized.compareAndSet(false, true) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Tracks the number of outstanding background requests in flight. The first time this count reaches 0, we publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Have we published the {@link TreeCacheEvent.Type#INITIALIZED} event yet?<br/>\n    +     */<br/>\n    +    private final AtomicBoolean isInitialized = new AtomicBoolean(false);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), \"already started\");\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache.<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close()<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    if ( root.path.length() > 1 )<br/>\n    +    {\n    +fullPath = fullPath.substring(root.path.length());\n    +    }<br/>\n    +    List<String> split = ZKPaths.split(fullPath);<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children at the given path, mapped by child name. There are no<br/>\n    +     * guarantees of accuracy; this is merely the most recent view of the data.  If there is no<br/>\n    +     * node at this path, {@code null} is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public Map<String, ChildData> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +Map<String, ChildData> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableMap.of();\n    +}\n<p>    +else<br/>\n    +{<br/>\n    +    ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();<br/>\n    +    for ( Map.Entry<String, TreeNode> entry : map.entrySet() )<br/>\n    +    {<br/>\n    +TreeNode childNode = entry.getValue();<br/>\n    +ChildData childData = new ChildData(childNode.path, childNode.stat.get(), childNode.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +if ( childNode.nodeState.get() == NodeState.LIVE )<br/>\n    +</p>\n{\n    +    builder.put(entry.getKey(), childData);\n    +}\n<p>    +    }<br/>\n    +    result = builder.build();<br/>\n    +}<br/>\n    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no node at the given path,<br/>\n    +     * </p>\n{@code null}\n<p> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    private void callListeners(final TreeCacheEvent event)<br/>\n    +    {<br/>\n    +listeners.forEach(new Function<TreeCacheListener, Void>()<br/>\n    +{<br/>\n    +    @Override<br/>\n    +    public Void apply(TreeCacheListener listener)<br/>\n    +    {<br/>\n    +try<br/>\n    +</p>\n{\n    +    listener.childEvent(client, event);\n    +}\n<p>    +catch ( Exception e )<br/>\n    +</p>\n{\n    +    handleException(e);\n    +}\n<p>    +return null;<br/>\n    +    }<br/>\n    +});<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Default behavior is just to log the exception<br/>\n    +     *<br/>\n    +     * @param e the exception<br/>\n    +     */<br/>\n    +    protected void handleException(Throwable e)<br/>\n    +    </p>\n{\n    +LOG.error(\"\", e);\n    +    }\n<p>    +<br/>\n    +    private void handleStateChange(ConnectionState newState)<br/>\n    +    {<br/>\n    +switch ( newState )<br/>\n    +{<br/>\n    +case SUSPENDED:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);<br/>\n    +    break;<br/>\n    +<br/>\n    +case LOST:<br/>\n    +    publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);<br/>\n    +    break;<br/>\n    +<br/>\n    +case RECONNECTED:<br/>\n    +    try<br/>\n    +    </p>\n{\n    +root.wasReconnected();\n    +publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);\n    +    }\n<p>    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +    break;<br/>\n    +}<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Ok, thanks, that makes sense.</p>\n\n<p>    All good from me then. Nice work.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695991/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695996","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695996","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695996,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU5OTY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T02:09:35Z","updated_at":"2025-01-21T13:10:47Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user asfgit closed the pull request at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695996/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702752","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702752","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702752,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3NTI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T05:55:14Z","updated_at":"2025-01-21T13:13:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cammckenzie\">cammckenzie</a>:</i>\n<p>So, a fix for this is more complicated than I was hoping.</p>\n\n<p>The recipes already use protected ephemeral nodes, so for the normal case where you attempt to create a node and lose the connection after you've submitted the create request but before you've got a response is covered. The problem is that this only handles the ConnectionLoss exception. If any other type of exception occurs then the logic to remove the potentially created ephemeral node does not fire.</p>\n\n<p>It is possible, but a bit messy to handle this at the LockInternals level. In the case of getting an exception while trying to create the zNode, we can try and remove the potentially created node, but we don't know its name. So, we'd need to query all the children of the parent lock path, and then work out which ones are ephemeral nodes owned by the current session, and aren't known about by the current lock instance (i.e. they are an orphan). I've implemented this, but it's a bit messy and requires changes to the clients of LockInternals.</p>\n\n<p>So, I think this needs some more thought. Perhaps the logic in the protected node handling can be extended to fire on any non KeeperException (other than ConnectionLoss). Any thoughts from anyone else?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702752/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51574445","html_url":"https://github.com/apache/curator/pull/17#issuecomment-51574445","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":51574445,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNTc0NDQ1","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T08:11:11Z","updated_at":"2014-08-08T08:11:11Z","author_association":"CONTRIBUTOR","body":"Thanks!  I'll follow up with the event unification we talked about.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51574445/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604696001","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604696001","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604696001,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTYwMDE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T08:11:21Z","updated_at":"2025-01-21T13:10:47Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-51574445\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-51574445</a></p>\n\n<p>    Thanks!  I'll follow up with the event unification we talked about.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604696001/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51598892","html_url":"https://github.com/apache/curator/pull/17#issuecomment-51598892","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":51598892,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNTk4ODky","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T13:21:12Z","updated_at":"2014-08-08T13:21:20Z","author_association":"MEMBER","body":"A Java 7ism got into the code. Please fix: https://issues.apache.org/jira/browse/CURATOR-137\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51598892/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604696004","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604696004","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604696004,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTYwMDQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T13:22:30Z","updated_at":"2025-01-21T13:10:47Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-51598892\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-51598892</a></p>\n\n<p>    A Java 7ism go into the code. Please fix: <a href=\"https://issues.apache.org/jira/browse/CURATOR-137\" class=\"external-link\" rel=\"nofollow\">https://issues.apache.org/jira/browse/CURATOR-137</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604696004/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711724","html_url":"https://github.com/apache/curator/issues/658#issuecomment-2604711724","issue_url":"https://api.github.com/repos/apache/curator/issues/658","id":2604711724,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE3MjQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T14:54:08Z","updated_at":"2025-01-21T13:17:32Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>Note that backporting the OpenJDK 7 implementation of AssertionError into our own code is not an option due to licence incompatibilities.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711724/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51625311","html_url":"https://github.com/apache/curator/pull/17#issuecomment-51625311","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":51625311,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNjI1MzEx","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T16:27:34Z","updated_at":"2014-08-08T16:27:34Z","author_association":"CONTRIBUTOR","body":"Oops, will fix.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51625311/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604696011","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604696011","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604696011,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTYwMTE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T16:27:45Z","updated_at":"2025-01-21T13:10:47Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-51625311\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-51625311</a></p>\n\n<p>    Oops, will fix.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604696011/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711729","html_url":"https://github.com/apache/curator/issues/658#issuecomment-2604711729","issue_url":"https://api.github.com/repos/apache/curator/issues/658","id":2604711729,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE3Mjk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T16:28:49Z","updated_at":"2025-01-21T13:17:32Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dragonsinth\">dragonsinth</a>:</i>\n<p>Oops, will fix.  Whats our preferred way to report multiple exceptions?  Just report the first?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711729/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711733","html_url":"https://github.com/apache/curator/issues/658#issuecomment-2604711733","issue_url":"https://api.github.com/repos/apache/curator/issues/658","id":2604711733,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE3MzM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T20:23:09Z","updated_at":"2025-01-21T13:17:32Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user dragonsinth opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/33\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/33</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-137\" title=\"BaseTestTreeCache does not compile using Java 6\" class=\"issue-link\" data-issue-key=\"CURATOR-137\"><del>CURATOR-137</del></a>: BaseTestTreeCache compiles for JDK6</p>\n\n\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/dragonsinth/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/dragonsinth/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-137\" title=\"BaseTestTreeCache does not compile using Java 6\" class=\"issue-link\" data-issue-key=\"CURATOR-137\"><del>CURATOR-137</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/33.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/33.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #33</p>\n\n<hr />\n<p>commit 6bd0cc3e9fff7a1af186893e051e305f636c0bee<br/>\nAuthor: Scott Blum <scottb@squareup.com><br/>\nDate:   2014-08-08T20:21:59Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-137\" title=\"BaseTestTreeCache does not compile using Java 6\" class=\"issue-link\" data-issue-key=\"CURATOR-137\"><del>CURATOR-137</del></a>: BaseTestTreeCache compiles for JDK6</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711733/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711734","html_url":"https://github.com/apache/curator/issues/658#issuecomment-2604711734","issue_url":"https://api.github.com/repos/apache/curator/issues/658","id":2604711734,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE3MzQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T20:27:51Z","updated_at":"2025-01-21T13:17:32Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user asfgit closed the pull request at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/33\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/33</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711734/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711605","html_url":"https://github.com/apache/curator/issues/657#issuecomment-2604711605","issue_url":"https://api.github.com/repos/apache/curator/issues/657","id":2604711605,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE2MDU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-08T21:32:04Z","updated_at":"2025-01-21T13:17:29Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>We should probably do a pass on all the recipes and make sure that passed in paths are valid.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711605/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711613","html_url":"https://github.com/apache/curator/issues/657#issuecomment-2604711613","issue_url":"https://api.github.com/repos/apache/curator/issues/657","id":2604711613,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE2MTM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-09T01:59:45Z","updated_at":"2025-01-21T13:17:29Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>I can try to go through them next week. It will be a good opportunity to visit them and learn.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711613/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711874","html_url":"https://github.com/apache/curator/issues/659#issuecomment-2604711874","issue_url":"https://api.github.com/repos/apache/curator/issues/659","id":2604711874,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE4NzQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-09T02:06:35Z","updated_at":"2025-01-21T13:17:36Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user dragonsinth opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/34\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/34</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-138\" title=\"Unify event listening for NodeCache, PathChildrenCache, TreeCache\" class=\"issue-link\" data-issue-key=\"CURATOR-138\"><del>CURATOR-138</del></a>: Unify event listening for NodeCache, PathChildrenCache, TreeCache</p>\n\n<p>    WIP.  Just wanted to run the basic idea by before I go much farther down this path.</p>\n\n<ul class=\"alternate\" type=\"square\">\n\t<li>Need tests for NodeCache</li>\n\t<li>Need to add new listener type to PathChildrenCache</li>\n\t<li>Need tests for PathChildrenCache</li>\n</ul>\n\n\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/dragonsinth/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/dragonsinth/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-138\" title=\"Unify event listening for NodeCache, PathChildrenCache, TreeCache\" class=\"issue-link\" data-issue-key=\"CURATOR-138\"><del>CURATOR-138</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/34.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/34.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #34</p>\n\n<hr />\n<p>commit f8ef2d9109d38133a34c99dab8362d5eef41ab99<br/>\nAuthor: Scott Blum <scottb@squareup.com><br/>\nDate:   2014-08-09T02:04:40Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-138\" title=\"Unify event listening for NodeCache, PathChildrenCache, TreeCache\" class=\"issue-link\" data-issue-key=\"CURATOR-138\"><del>CURATOR-138</del></a>: Unify event listening for NodeCache, PathChildrenCache, TreeCache</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711874/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51721908","html_url":"https://github.com/apache/curator/pull/34#issuecomment-51721908","issue_url":"https://api.github.com/repos/apache/curator/issues/34","id":51721908,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNzIxOTA4","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-10T17:56:37Z","updated_at":"2014-08-10T17:56:37Z","author_association":"MEMBER","body":"I wonder if we should unify TreeCache and PathChildrenCache as well.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51721908/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711880","html_url":"https://github.com/apache/curator/issues/659#issuecomment-2604711880","issue_url":"https://api.github.com/repos/apache/curator/issues/659","id":2604711880,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE4ODA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-10T17:56:49Z","updated_at":"2025-01-21T13:17:36Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/34#issuecomment-51721908\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/34#issuecomment-51721908</a></p>\n\n<p>    I wonder if we should unify TreeCache and PathChildrenCache as well.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711880/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51722381","html_url":"https://github.com/apache/curator/pull/34#issuecomment-51722381","issue_url":"https://api.github.com/repos/apache/curator/issues/34","id":51722381,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNzIyMzgx","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-10T18:13:22Z","updated_at":"2014-08-10T18:13:22Z","author_association":"CONTRIBUTOR","body":"Yeah, that's absolutely the plan.  I just wanted to make sure I was heading in the right direction before doing the work in PathChildrenCache (and writing tests).\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51722381/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711890","html_url":"https://github.com/apache/curator/issues/659#issuecomment-2604711890","issue_url":"https://api.github.com/repos/apache/curator/issues/659","id":2604711890,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE4OTA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-10T18:13:37Z","updated_at":"2025-01-21T13:17:36Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/34#issuecomment-51722381\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/34#issuecomment-51722381</a></p>\n\n<p>    Yeah, that's absolutely the plan.  I just wanted to make sure I was heading in the right direction before doing the work in PathChildrenCache (and writing tests).</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711890/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702759","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702759","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702759,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3NTk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T01:27:37Z","updated_at":"2025-01-21T13:13:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user cammckenzie opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-79\" title=\"InterProcessMutex doesn&#39;t clean up after interrupt\" class=\"issue-link\" data-issue-key=\"CURATOR-79\"><del>CURATOR-79</del></a> - Modified the 'withProtection' handling, so that any failure</p>\n\n<p>    that is not a ConnectionLossException or other KeeperException is<br/>\n    treated the same as a ConnectionLossException. This means that if the<br/>\n    thread gets interrupted, or encounters some sort of other error, during<br/>\n    creation of a protected zNode, it will remove the affected zNode prior<br/>\n    to rethrowing the exception.</p>\n\n<p>    Exposed the debug UnhandledExceptionListener on the CuratorFrameworkImpl<br/>\n    to reproduce this issue via a unit test.</p>\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/apache/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-79\" title=\"InterProcessMutex doesn&#39;t clean up after interrupt\" class=\"issue-link\" data-issue-key=\"CURATOR-79\"><del>CURATOR-79</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #35</p>\n\n<hr />\n<p>commit 5398b72f00ccc0f2ea995865fcaf92d73c6c5818<br/>\nAuthor: Cam McKenzie <cammckenzie@apache.org><br/>\nDate:   2014-08-10T22:13:12Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-79\" title=\"InterProcessMutex doesn&#39;t clean up after interrupt\" class=\"issue-link\" data-issue-key=\"CURATOR-79\"><del>CURATOR-79</del></a> - Modified the 'withProtection' handling, so that any failure<br/>\n    that is not a ConnectionLossException or other KeeperException is<br/>\n    treated the same as a ConnectionLossException. This means that if the<br/>\n    thread gets interrupted, or encounters some sort of other error, during<br/>\n    creation of a protected zNode, it will remove the affected zNode prior<br/>\n    to rethrowing the exception.</p>\n\n<p>    Exposed the debug UnhandledExceptionListener on the CuratorFrameworkImpl<br/>\n    to reproduce this issue via a unit test.</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702759/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/51744543","html_url":"https://github.com/apache/curator/pull/29#issuecomment-51744543","issue_url":"https://api.github.com/repos/apache/curator/issues/29","id":51744543,"node_id":"MDEyOklzc3VlQ29tbWVudDUxNzQ0NTQz","user":{"login":"cammckenzie","id":7763121,"node_id":"MDQ6VXNlcjc3NjMxMjE=","avatar_url":"https://avatars.githubusercontent.com/u/7763121?v=4","gravatar_id":"","url":"https://api.github.com/users/cammckenzie","html_url":"https://github.com/cammckenzie","followers_url":"https://api.github.com/users/cammckenzie/followers","following_url":"https://api.github.com/users/cammckenzie/following{/other_user}","gists_url":"https://api.github.com/users/cammckenzie/gists{/gist_id}","starred_url":"https://api.github.com/users/cammckenzie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cammckenzie/subscriptions","organizations_url":"https://api.github.com/users/cammckenzie/orgs","repos_url":"https://api.github.com/users/cammckenzie/repos","events_url":"https://api.github.com/users/cammckenzie/events{/privacy}","received_events_url":"https://api.github.com/users/cammckenzie/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T06:01:14Z","updated_at":"2014-08-11T06:01:14Z","author_association":"CONTRIBUTOR","body":"Looks good to me.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/51744543/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710870","html_url":"https://github.com/apache/curator/issues/652#issuecomment-2604710870","issue_url":"https://api.github.com/repos/apache/curator/issues/652","id":2604710870,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA4NzA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T06:01:23Z","updated_at":"2025-01-21T13:17:10Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/29#issuecomment-51744543\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/29#issuecomment-51744543</a></p>\n\n<p>    Looks good to me.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710870/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710874","html_url":"https://github.com/apache/curator/issues/652#issuecomment-2604710874","issue_url":"https://api.github.com/repos/apache/curator/issues/652","id":2604710874,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA4NzQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T06:32:10Z","updated_at":"2025-01-21T13:17:10Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user asfgit closed the pull request at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/29\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/29</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710874/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702767","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702767","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702767,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3Njc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T13:59:02Z","updated_at":"2025-01-21T13:13:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user madrob commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16053962\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16053962</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/test/java/org/apache/curator/framework/recipes/locks/TestInterProcessMutex.java &#8212;<br/>\n    @@ -107,4 +113,70 @@ public Void call() throws Exception<br/>\n client.close();<br/>\n     }<br/>\n }<br/>\n    +    <br/>\n    +    /**<br/>\n    +     * See <a href=\"https://issues.apache.org/jira/browse/CURATOR-79\" title=\"InterProcessMutex doesn&#39;t clean up after interrupt\" class=\"issue-link\" data-issue-key=\"CURATOR-79\"><del>CURATOR-79</del></a>. If the mutex is interrupted while attempting to acquire a lock it is<br/>\n    +     * possible for the zNode to be created in ZooKeeper, but for Curator to think that it<br/>\n    +     * hasn't been. This causes the next call to acquire() to fail because the an orphaned<br/>\n    +     * zNode has been left behind from the previous call.<br/>\n    +     */<br/>\n    +    @Test<br/>\n    +    public void testInterruptedDuringAcquire() throws Exception<br/>\n    +    {<br/>\n    +Timing timing = new Timing();<br/>\n    +final CuratorFrameworkclient = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));<br/>\n    +client.start();<br/>\n    +final InterProcessMutex       lock = new InterProcessMutex(client, LOCK_PATH);<br/>\n    +<br/>\n    +final AtomicBoolean interruptOnError = new AtomicBoolean(true);<br/>\n    +<br/>\n    +((CuratorFrameworkImpl)client).debugUnhandledErrorListener = new UnhandledErrorListener()<br/>\n    +{<br/>\n    +    <br/>\n    +    @Override<br/>\n    +    public void unhandledError(String message, Throwable e)<br/>\n    +    {<br/>\n    +if(interruptOnError.compareAndSet(true, false))<br/>\n    +</p>\n{\n    +    Thread.currentThread().interrupt();\n    +}\n<p>    +    }<br/>\n    +};<br/>\n    +<br/>\n    +//The lock path needs to exist for the deadlock to occur.<br/>\n    +try </p>\n{\n    +    client.create().creatingParentsIfNeeded().forPath(LOCK_PATH);\n    +}\n<p> catch(NodeExistsException e) </p>\n{    \n    +}\n<p>    +<br/>\n    +try<br/>\n    +</p>\n{\n    +    //Interrupt the current thread. This will cause ensurePath() to fail.\n    +    //We need to reinterrupt in the debugUnhandledErrorListener above.\n    +    Thread.currentThread().interrupt();\n    +    lock.acquire();\n    +    Assert.fail();\n    +}\n<p>    +catch(InterruptedException e)<br/>\n    +{<br/>\n    +    //Expected lock to have failed.<br/>\n    +    Assert.assertTrue(!lock.isOwnedByCurrentThread());<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    nit: assertFalse</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702767/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702770","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702770","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702770,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3NzA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T13:59:37Z","updated_at":"2025-01-21T13:13:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user madrob commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16053998\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16053998</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/test/java/org/apache/curator/framework/recipes/locks/TestInterProcessMutex.java &#8212;<br/>\n    @@ -107,4 +113,70 @@ public Void call() throws Exception<br/>\n client.close();<br/>\n     }<br/>\n }<br/>\n    +    <br/>\n    +    /**<br/>\n    +     * See <a href=\"https://issues.apache.org/jira/browse/CURATOR-79\" title=\"InterProcessMutex doesn&#39;t clean up after interrupt\" class=\"issue-link\" data-issue-key=\"CURATOR-79\"><del>CURATOR-79</del></a>. If the mutex is interrupted while attempting to acquire a lock it is<br/>\n    +     * possible for the zNode to be created in ZooKeeper, but for Curator to think that it<br/>\n    +     * hasn't been. This causes the next call to acquire() to fail because the an orphaned<br/>\n    +     * zNode has been left behind from the previous call.<br/>\n    +     */<br/>\n    +    @Test<br/>\n    +    public void testInterruptedDuringAcquire() throws Exception<br/>\n    +    {<br/>\n    +Timing timing = new Timing();<br/>\n    +final CuratorFrameworkclient = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));<br/>\n    +client.start();<br/>\n    +final InterProcessMutex       lock = new InterProcessMutex(client, LOCK_PATH);<br/>\n    +<br/>\n    +final AtomicBoolean interruptOnError = new AtomicBoolean(true);<br/>\n    +<br/>\n    +((CuratorFrameworkImpl)client).debugUnhandledErrorListener = new UnhandledErrorListener()<br/>\n    +{<br/>\n    +    <br/>\n    +    @Override<br/>\n    +    public void unhandledError(String message, Throwable e)<br/>\n    +    {<br/>\n    +if(interruptOnError.compareAndSet(true, false))<br/>\n    +</p>\n{\n    +    Thread.currentThread().interrupt();\n    +}\n<p>    +    }<br/>\n    +};<br/>\n    +<br/>\n    +//The lock path needs to exist for the deadlock to occur.<br/>\n    +try </p>\n{\n    +    client.create().creatingParentsIfNeeded().forPath(LOCK_PATH);\n    +}\n<p> catch(NodeExistsException e) </p>\n{    \n    +}\n<p>    +<br/>\n    +try<br/>\n    +{<br/>\n    +    //Interrupt the current thread. This will cause ensurePath() to fail.<br/>\n    +    //We need to reinterrupt in the debugUnhandledErrorListener above.<br/>\n    +    Thread.currentThread().interrupt();<br/>\n    +    lock.acquire();<br/>\n    +    Assert.fail();<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Can you add a message to the fail(), in case we see a regression in the future?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702770/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702778","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702778","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702778,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3Nzg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T14:03:12Z","updated_at":"2025-01-21T13:13:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16054205\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16054205</a></p>\n\n<p>    &#8212; Diff: curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java &#8212;<br/>\n    @@ -469,6 +469,26 @@ private String protectedPathInForeground(String adjustedPath, byte[] data) throw<br/>\n }<br/>\n throw e;<br/>\n     }<br/>\n    +catch ( KeeperException e )<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    I think the 3 catch clauses can be combined for clarity.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702778/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702782","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702782","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702782,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3ODI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T14:10:45Z","updated_at":"2025-01-21T13:13:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user madrob commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16054657\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16054657</a></p>\n\n<p>    &#8212; Diff: curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java &#8212;<br/>\n    @@ -469,6 +469,26 @@ private String protectedPathInForeground(String adjustedPath, byte[] data) throw<br/>\n }<br/>\n throw e;<br/>\n     }<br/>\n    +catch ( KeeperException e )<br/>\n    +</p>\n{\n    +    throw e;\n    +}\n<p>    +catch ( Exception e )<br/>\n    +{<br/>\n    +    if ( protectedId != null )<br/>\n    +    {<br/>\n    +/*<br/>\n    + * <a href=\"https://issues.apache.org/jira/browse/CURATOR-79\" title=\"InterProcessMutex doesn&#39;t clean up after interrupt\" class=\"issue-link\" data-issue-key=\"CURATOR-79\"><del>CURATOR-79</del></a> - Handle an runtime exception's here and treat the<br/>\n    + * same as a connection loss exception. This is necessary as, from<br/>\n    + * the clients point of view, an exception has been thrown and the<br/>\n    + * zNode should not exist on ZK. This was causing deadlock in the<br/>\n    + * locking recipes.<br/>\n    + */<br/>\n    +findAndDeleteProtectedNodeInBackground(adjustedPath, protectedId, null);<br/>\n    +protectedId = UUID.randomUUID().toString();<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Is there a possible race condition between issuing the background delete and reassigning the protectedId? I almost think we would want to swap the order. (Intuition only, no concerete examples of this).</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702782/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702785","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702785","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702785,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3ODU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T14:18:55Z","updated_at":"2025-01-21T13:13:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16055156\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16055156</a></p>\n\n<p>    &#8212; Diff: curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java &#8212;<br/>\n    @@ -469,6 +469,26 @@ private String protectedPathInForeground(String adjustedPath, byte[] data) throw<br/>\n }<br/>\n throw e;<br/>\n     }<br/>\n    +catch ( KeeperException e )<br/>\n    +</p>\n{\n    +    throw e;\n    +}\n<p>    +catch ( Exception e )<br/>\n    +{<br/>\n    +    if ( protectedId != null )<br/>\n    +    {<br/>\n    +/*<br/>\n    + * <a href=\"https://issues.apache.org/jira/browse/CURATOR-79\" title=\"InterProcessMutex doesn&#39;t clean up after interrupt\" class=\"issue-link\" data-issue-key=\"CURATOR-79\"><del>CURATOR-79</del></a> - Handle an runtime exception's here and treat the<br/>\n    + * same as a connection loss exception. This is necessary as, from<br/>\n    + * the clients point of view, an exception has been thrown and the<br/>\n    + * zNode should not exist on ZK. This was causing deadlock in the<br/>\n    + * locking recipes.<br/>\n    + */<br/>\n    +findAndDeleteProtectedNodeInBackground(adjustedPath, protectedId, null);<br/>\n    +protectedId = UUID.randomUUID().toString();<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    It can't be reversed. If it were reversed, the wrong ID would be passed. Maybe for clarity, a localProtectedId can be assigned and passed to findAndDeleteProtectedNodeInBackground()</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702785/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702789","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702789","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702789,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3ODk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T15:03:05Z","updated_at":"2025-01-21T13:13:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user madrob commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16057954\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16057954</a></p>\n\n<p>    &#8212; Diff: curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java &#8212;<br/>\n    @@ -469,6 +469,26 @@ private String protectedPathInForeground(String adjustedPath, byte[] data) throw<br/>\n }<br/>\n throw e;<br/>\n     }<br/>\n    +catch ( KeeperException e )<br/>\n    +</p>\n{\n    +    throw e;\n    +}\n<p>    +catch ( Exception e )<br/>\n    +{<br/>\n    +    if ( protectedId != null )<br/>\n    +    {<br/>\n    +/*<br/>\n    + * <a href=\"https://issues.apache.org/jira/browse/CURATOR-79\" title=\"InterProcessMutex doesn&#39;t clean up after interrupt\" class=\"issue-link\" data-issue-key=\"CURATOR-79\"><del>CURATOR-79</del></a> - Handle an runtime exception's here and treat the<br/>\n    + * same as a connection loss exception. This is necessary as, from<br/>\n    + * the clients point of view, an exception has been thrown and the<br/>\n    + * zNode should not exist on ZK. This was causing deadlock in the<br/>\n    + * locking recipes.<br/>\n    + */<br/>\n    +findAndDeleteProtectedNodeInBackground(adjustedPath, protectedId, null);<br/>\n    +protectedId = UUID.randomUUID().toString();<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Yes, copy the existing ID, generate and assign a new one, and then delete the old one.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702789/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702792","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702792","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702792,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3OTI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T17:58:09Z","updated_at":"2025-01-21T13:13:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user ortschun commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16068759\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16068759</a></p>\n\n<p>    &#8212; Diff: curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java &#8212;<br/>\n    @@ -469,6 +469,26 @@ private String protectedPathInForeground(String adjustedPath, byte[] data) throw<br/>\n }<br/>\n throw e;<br/>\n     }<br/>\n    +catch ( KeeperException e )<br/>\n    +</p>\n{\n    +    throw e;\n    +}\n<p>    +catch ( Exception e )<br/>\n    +{<br/>\n    +    if ( protectedId != null )<br/>\n    +    {<br/>\n    +/*<br/>\n    + * <a href=\"https://issues.apache.org/jira/browse/CURATOR-79\" title=\"InterProcessMutex doesn&#39;t clean up after interrupt\" class=\"issue-link\" data-issue-key=\"CURATOR-79\"><del>CURATOR-79</del></a> - Handle an runtime exception's here and treat the<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    nit: could you fix the sentence, as something like \"Handle runtime exceptions here\"</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702792/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711617","html_url":"https://github.com/apache/curator/issues/657#issuecomment-2604711617","issue_url":"https://api.github.com/repos/apache/curator/issues/657","id":2604711617,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE2MTc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T20:12:57Z","updated_at":"2025-01-21T13:17:29Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>So in this particular case, it's hanging in <tt>await()</tt> and since you never gave it a time-out, then it makes sense that it would never return since it can't find the path.</p>\n\n<p>Is your suggestion to check the path in the constructor, John?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711617/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711621","html_url":"https://github.com/apache/curator/issues/657#issuecomment-2604711621","issue_url":"https://api.github.com/repos/apache/curator/issues/657","id":2604711621,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTE2MjE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T20:15:06Z","updated_at":"2025-01-21T13:17:29Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>Part of the problem is that <tt>start()</tt> takes the path and 'normalizes' it by pre-pending a / to it in, I think it was CreateBuilderImpl. However, there is a code path that goes through the callback and into GetChildrenBuilderImpl that does not do the same.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711621/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604712183","html_url":"https://github.com/apache/curator/issues/660#issuecomment-2604712183","issue_url":"https://api.github.com/repos/apache/curator/issues/660","id":2604712183,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTIxODM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T21:37:05Z","updated_at":"2025-01-21T13:17:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user madrob opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/36\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/36</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-139\" title=\"Add slf4j logging implementation to test scope\" class=\"issue-link\" data-issue-key=\"CURATOR-139\"><del>CURATOR-139</del></a> Add slf4j-log4j test bindings</p>\n\n<p>    Add test bindings so that log output is preserved. Makes it easier to<br/>\n    debug jenkins and failed unit tests, which not appreciably increasing<br/>\n    the time to run or disk space used.</p>\n\n<p>    This closes #36</p>\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/madrob/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/madrob/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-139\" title=\"Add slf4j logging implementation to test scope\" class=\"issue-link\" data-issue-key=\"CURATOR-139\"><del>CURATOR-139</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/36.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/36.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #36</p>\n\n<hr />\n<p>commit 104837d0739647729eef58f7d2dc29c3fb62f89e<br/>\nAuthor: Mike Drob <mdrob@cloudera.com><br/>\nDate:   2014-08-11T21:34:33Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-139\" title=\"Add slf4j logging implementation to test scope\" class=\"issue-link\" data-issue-key=\"CURATOR-139\"><del>CURATOR-139</del></a> Add slf4j-log4j test bindings</p>\n\n<p>    Add test bindings so that log output is preserved. Makes it easier to<br/>\n    debug jenkins and failed unit tests, which not appreciably increasing<br/>\n    the time to run or disk space used.</p>\n\n<p>    This closes #36</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604712183/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604712191","html_url":"https://github.com/apache/curator/issues/660#issuecomment-2604712191","issue_url":"https://api.github.com/repos/apache/curator/issues/660","id":2604712191,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTIxOTE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T21:39:20Z","updated_at":"2025-01-21T13:17:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>The log output was ~6M, which doesn't strike me as a big deal. The total runtime on my (not that powerful) laptop changed by less than a minute, which I assume is just variance. Sanity check looks good from my end.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604712191/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702797","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702797","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702797,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI3OTc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T21:55:25Z","updated_at":"2025-01-21T13:13:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16083287\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16083287</a></p>\n\n<p>    &#8212; Diff: curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java &#8212;<br/>\n    @@ -469,6 +469,26 @@ private String protectedPathInForeground(String adjustedPath, byte[] data) throw<br/>\n }<br/>\n throw e;<br/>\n     }<br/>\n    +catch ( KeeperException e )<br/>\n    +</p>\n{\n    +    throw e;\n    +}\n<p>    +catch ( Exception e )<br/>\n    +{<br/>\n    +    if ( protectedId != null )<br/>\n    +    {<br/>\n    +/*<br/>\n    + * <a href=\"https://issues.apache.org/jira/browse/CURATOR-79\" title=\"InterProcessMutex doesn&#39;t clean up after interrupt\" class=\"issue-link\" data-issue-key=\"CURATOR-79\"><del>CURATOR-79</del></a> - Handle an runtime exception's here and treat the<br/>\n    + * same as a connection loss exception. This is necessary as, from<br/>\n    + * the clients point of view, an exception has been thrown and the<br/>\n    + * zNode should not exist on ZK. This was causing deadlock in the<br/>\n    + * locking recipes.<br/>\n    + */<br/>\n    +findAndDeleteProtectedNodeInBackground(adjustedPath, protectedId, null);<br/>\n    +protectedId = UUID.randomUUID().toString();<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    I don't think there's a race condition given that the findAndDeleteProtectionNodeInBackground is being passed a reference to the ID it needs to delete. I will change to assign to a local variable and pass this to the findAndDeleteProtectionNodeInBackground method for clarity.</p>\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702797/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702802","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702802","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702802,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI4MDI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T21:55:50Z","updated_at":"2025-01-21T13:13:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16083310\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16083310</a></p>\n\n<p>    &#8212; Diff: curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java &#8212;<br/>\n    @@ -469,6 +469,26 @@ private String protectedPathInForeground(String adjustedPath, byte[] data) throw<br/>\n }<br/>\n throw e;<br/>\n     }<br/>\n    +catch ( KeeperException e )<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    By this I presume you mean catch Exception and then do a conditional instanceof?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702802/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702813","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702813","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702813,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI4MTM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T22:00:36Z","updated_at":"2025-01-21T13:13:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16083651\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16083651</a></p>\n\n<p>    &#8212; Diff: curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java &#8212;<br/>\n    @@ -469,6 +469,26 @@ private String protectedPathInForeground(String adjustedPath, byte[] data) throw<br/>\n }<br/>\n throw e;<br/>\n     }<br/>\n    +catch ( KeeperException e )<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    I think it would be cleaner because there a duplicated block of code now. Or, move the duplicated code into a new method.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702813/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702818","html_url":"https://github.com/apache/curator/issues/600#issuecomment-2604702818","issue_url":"https://api.github.com/repos/apache/curator/issues/600","id":2604702818,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDI4MTg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-11T22:03:35Z","updated_at":"2025-01-21T13:13:44Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/35#discussion_r16083843\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/35#discussion_r16083843</a></p>\n\n<p>    &#8212; Diff: curator-framework/src/main/java/org/apache/curator/framework/imps/CreateBuilderImpl.java &#8212;<br/>\n    @@ -469,6 +469,26 @@ private String protectedPathInForeground(String adjustedPath, byte[] data) throw<br/>\n }<br/>\n throw e;<br/>\n     }<br/>\n    +catch ( KeeperException e )<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Yep, agreed, I will put it into a generic catch.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604702818/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711288","html_url":"https://github.com/apache/curator/issues/655#issuecomment-2604711288","issue_url":"https://api.github.com/repos/apache/curator/issues/655","id":2604711288,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEyODg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-12T03:42:27Z","updated_at":"2025-01-21T13:17:21Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cammckenzie\">cammckenzie</a>:</i>\n<p>I've had a look into this and can certainly reproduce it. It appears that the 'LOST' state will be published if no connection to ZK can be established, regardless of how long the session is.</p>\n\n<p>The amount of time it takes for the 'LOST' state to be published depends upon the retry policy, but due to the way that the RetryLoop is implemented, it will block for at least the specified connection timeout on each iteration of the retry loop. Once retries have been exhausted then the state LOST state is published.</p>\n\n<p>This can be incorrect. If the client can't connect to ZK for some period of time due to a network glitch, but the ZK cluster is still alive then the session is not LOST and will be reestablished on reconnection (should that occur before session timeout).</p>\n\n<p>So, I guess Curator should keep retrying until the configured session timeout expires.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711288/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711297","html_url":"https://github.com/apache/curator/issues/655#issuecomment-2604711297","issue_url":"https://api.github.com/repos/apache/curator/issues/655","id":2604711297,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEyOTc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-12T13:13:27Z","updated_at":"2025-01-21T13:17:21Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>The doc for LOST says \"The connection is confirmed to be lost\". It doesn't imply that session is lost. The LOST event is sent when Curator has given up trying to maintain the connection. Curator gives up if it can't connect within the connection timeout and/or the retry policy fails. We should not change the meaning of LOST to be session loss.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711297/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711302","html_url":"https://github.com/apache/curator/issues/655#issuecomment-2604711302","issue_url":"https://api.github.com/repos/apache/curator/issues/655","id":2604711302,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEzMDI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-12T16:42:59Z","updated_at":"2025-01-21T13:17:21Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=benjamin.jaton\">benjamin.jaton</a>:</i>\n<p>Regardless of the sessionTimeout, with a RetryNTimes(3,10000) retry policy, I think we shouldn't have a LOST event 13 seconds after the last RECONNECTED event, it should be >= 30 seconds.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711302/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711306","html_url":"https://github.com/apache/curator/issues/655#issuecomment-2604711306","issue_url":"https://api.github.com/repos/apache/curator/issues/655","id":2604711306,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEzMDY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-12T19:02:00Z","updated_at":"2025-01-21T13:17:21Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>OK - that definitely sounds like a problem.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711306/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604703663","html_url":"https://github.com/apache/curator/issues/605#issuecomment-2604703663","issue_url":"https://api.github.com/repos/apache/curator/issues/605","id":2604703663,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDM2NjM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-12T20:57:01Z","updated_at":"2025-01-21T13:14:03Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=karthik.kumar\">karthik.kumar</a>:</i>\n<p>I would love to see this change be considered for the next release!</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604703663/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]