[{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710464","html_url":"https://github.com/apache/curator/issues/649#issuecomment-2604710464","issue_url":"https://api.github.com/repos/apache/curator/issues/649","id":2604710464,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA0NjQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-29T13:04:00Z","updated_at":"2025-01-21T13:16:59Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=vines\">vines</a>:</i>\n<p>It seems like a really large inconsistency that can cause unexpected errors to users if they are using CuratorFramework's in both the root namespace and a non-root namespace because they need different logic for building paths in each.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710464/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710471","html_url":"https://github.com/apache/curator/issues/649#issuecomment-2604710471","issue_url":"https://api.github.com/repos/apache/curator/issues/649","id":2604710471,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA0NzE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-29T13:07:01Z","updated_at":"2025-01-21T13:17:00Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>As long as we don't break existing users it's OK with me. But, we should take considerable caution. </p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710471/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710474","html_url":"https://github.com/apache/curator/issues/649#issuecomment-2604710474","issue_url":"https://api.github.com/repos/apache/curator/issues/649","id":2604710474,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA0NzQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-29T13:10:53Z","updated_at":"2025-01-21T13:17:00Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=vines\">vines</a>:</i>\n<p>I think Scott's suggestion is the best, in that case. Formerly correct behavior is still correct. But now behavior which would previously fail will now pass. So unless users were depending on that error condition it should be fine.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710474/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710478","html_url":"https://github.com/apache/curator/issues/649#issuecomment-2604710478","issue_url":"https://api.github.com/repos/apache/curator/issues/649","id":2604710478,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA0Nzg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-29T15:47:30Z","updated_at":"2025-01-21T13:17:00Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dragonsinth\">dragonsinth</a>:</i>\n<p>Sure let me give a very concrete problem this is causing.</p>\n\n<p>I'm using the TreeCache (<a href=\"https://issues.apache.org/jira/browse/CURATOR-33\" title=\"Recursive Node Cache\" class=\"issue-link\" data-issue-key=\"CURATOR-33\"><del>CURATOR-33</del></a>) to mirror a ZK tree or subtree out to the local filesystem (like zkfuse, but it just actively mirrors to the local disk instead of being a FUSE partition).</p>\n\n<p>Sometimes I'd like to mirror a subtree out to disk using its full path in ZK, e.g. `new TreeCache(client, \"/ldap/users\", false)` such that the event stream has paths all prefixed with \"/ldap/users\".  But other times I want to namespace the incoming client to shorten the mirrored paths, e.g. `new TreeCache(client.usingNamespace(\"ldap/users\"), \"/\", false)`.</p>\n\n<p>That second formulation, I can't make it work right now because there's no way to address the root node of a namespace such that it combines correctly.  I can provide more extensive test cases to demo the problem if that would be helpful.</p>\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710478/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604697368","html_url":"https://github.com/apache/curator/issues/563#issuecomment-2604697368","issue_url":"https://api.github.com/repos/apache/curator/issues/563","id":2604697368,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTczNjg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-29T22:10:56Z","updated_at":"2025-01-21T13:11:22Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user Randgalt opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/24\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/24</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-42\" title=\"Background guaranteed delete considers NoNode to be a failed delete, and retries it\" class=\"issue-link\" data-issue-key=\"CURATOR-42\"><del>CURATOR-42</del></a> - Modified guaranteed delete handling so that it will only</p>\n\n<p>    add the node to the guaranteed delete set if a recoverable exception is<br/>\n    encountered. If a non recoverable exception (such as a NoNodeException)<br/>\n    is encountered, then this will not be retried. Added a debug listener to<br/>\n    the FailedDeleteManager to facilitate unit testing this case. Added unit<br/>\n    tests, for both guaranteed deletes in the background and foreground for<br/>\n    the NoNodeException case. Note that this error was only present for<br/>\n    guaranteed deletes in the foreground.</p>\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/apache/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-42\" title=\"Background guaranteed delete considers NoNode to be a failed delete, and retries it\" class=\"issue-link\" data-issue-key=\"CURATOR-42\"><del>CURATOR-42</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/24.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/24.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #24</p>\n\n<hr />\n<p>commit b174dfb145ebaea51bcd348cec950997725e7b3f<br/>\nAuthor: Cameron McKenzie <cameron@unico.com.au><br/>\nDate:   2014-07-29T22:06:25Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-42\" title=\"Background guaranteed delete considers NoNode to be a failed delete, and retries it\" class=\"issue-link\" data-issue-key=\"CURATOR-42\"><del>CURATOR-42</del></a> - Modified guaranteed delete handling so that it will only<br/>\n    add the node to the guaranteed delete set if a recoverable exception is<br/>\n    encountered. If a non recoverable exception (such as a NoNodeException)<br/>\n    is encountered, then this will not be retried. Added a debug listener to<br/>\n    the FailedDeleteManager to facilitate unit testing this case. Added unit<br/>\n    tests, for both guaranteed deletes in the background and foreground for<br/>\n    the NoNodeException case. Note that this error was only present for<br/>\n    guaranteed deletes in the foreground.</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604697368/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50546721","html_url":"https://github.com/apache/curator/pull/24#issuecomment-50546721","issue_url":"https://api.github.com/repos/apache/curator/issues/24","id":50546721,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNTQ2NzIx","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-29T22:13:04Z","updated_at":"2014-07-29T22:13:04Z","author_association":"MEMBER","body":"LGTM\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50546721/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604697371","html_url":"https://github.com/apache/curator/issues/563#issuecomment-2604697371","issue_url":"https://api.github.com/repos/apache/curator/issues/563","id":2604697371,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTczNzE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-29T22:13:10Z","updated_at":"2025-01-21T13:11:22Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/24#issuecomment-50546721\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/24#issuecomment-50546721</a></p>\n\n<p>    LGTM</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604697371/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50546875","html_url":"https://github.com/apache/curator/pull/24#issuecomment-50546875","issue_url":"https://api.github.com/repos/apache/curator/issues/24","id":50546875,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNTQ2ODc1","user":{"login":"cammckenzie","id":7763121,"node_id":"MDQ6VXNlcjc3NjMxMjE=","avatar_url":"https://avatars.githubusercontent.com/u/7763121?v=4","gravatar_id":"","url":"https://api.github.com/users/cammckenzie","html_url":"https://github.com/cammckenzie","followers_url":"https://api.github.com/users/cammckenzie/followers","following_url":"https://api.github.com/users/cammckenzie/following{/other_user}","gists_url":"https://api.github.com/users/cammckenzie/gists{/gist_id}","starred_url":"https://api.github.com/users/cammckenzie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cammckenzie/subscriptions","organizations_url":"https://api.github.com/users/cammckenzie/orgs","repos_url":"https://api.github.com/users/cammckenzie/repos","events_url":"https://api.github.com/users/cammckenzie/events{/privacy}","received_events_url":"https://api.github.com/users/cammckenzie/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-29T22:14:22Z","updated_at":"2014-07-29T22:14:22Z","author_association":"CONTRIBUTOR","body":"Thanks for the quick review\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50546875/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604697373","html_url":"https://github.com/apache/curator/issues/563#issuecomment-2604697373","issue_url":"https://api.github.com/repos/apache/curator/issues/563","id":2604697373,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTczNzM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-29T22:14:27Z","updated_at":"2025-01-21T13:11:22Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/24#issuecomment-50546875\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/24#issuecomment-50546875</a></p>\n\n<p>    Thanks for the quick review</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604697373/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604697376","html_url":"https://github.com/apache/curator/issues/563#issuecomment-2604697376","issue_url":"https://api.github.com/repos/apache/curator/issues/563","id":2604697376,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTczNzY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-29T23:08:26Z","updated_at":"2025-01-21T13:11:22Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user asfgit closed the pull request at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/24\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/24</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604697376/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604706871","html_url":"https://github.com/apache/curator/issues/627#issuecomment-2604706871","issue_url":"https://api.github.com/repos/apache/curator/issues/627","id":2604706871,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDY4NzE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T00:49:57Z","updated_at":"2025-01-21T13:15:29Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cammckenzie\">cammckenzie</a>:</i>\n<p>I have had a look at this as well, and I don't think that it can recurse because the client.delete().guaranteed().inBackground().forPath(path) call shouldn't ever throw an exception because it's running in the background.</p>\n\n<p>Perhaps instead of recursing in the case of an exception (which could only happen due to some sort of bug), it should just log an error?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604706871/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604708354","html_url":"https://github.com/apache/curator/issues/636#issuecomment-2604708354","issue_url":"https://api.github.com/repos/apache/curator/issues/636","id":2604708354,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDgzNTQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T00:52:25Z","updated_at":"2025-01-21T13:16:08Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cammckenzie\">cammckenzie</a>:</i>\n<p>Can you see if you can reproduce this against Curator 1.6.0? I believe that <a href=\"https://issues.apache.org/jira/browse/CURATOR-116\" title=\"Ordering of delayed distributed queue is inconsistent\" class=\"issue-link\" data-issue-key=\"CURATOR-116\"><del>CURATOR-116</del></a> should fix this issue.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604708354/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710485","html_url":"https://github.com/apache/curator/issues/649#issuecomment-2604710485","issue_url":"https://api.github.com/repos/apache/curator/issues/649","id":2604710485,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA0ODU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T01:05:00Z","updated_at":"2025-01-21T13:17:00Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user dragonsinth opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/25\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/25</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-128\" title=\"Enhance ZKPaths to be more lenient\" class=\"issue-link\" data-issue-key=\"CURATOR-128\"><del>CURATOR-128</del></a>: access root node within a namespace; more lenient ZKPaths.makePath</p>\n\n\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/dragonsinth/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/dragonsinth/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-128\" title=\"Enhance ZKPaths to be more lenient\" class=\"issue-link\" data-issue-key=\"CURATOR-128\"><del>CURATOR-128</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/25.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/25.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #25</p>\n\n<hr />\n<p>commit b83ab9d24eae882d5ca5f6efc0015103ae20f944<br/>\nAuthor: Scott Blum <scottb@squareup.com><br/>\nDate:   2014-07-30T00:17:11Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-128\" title=\"Enhance ZKPaths to be more lenient\" class=\"issue-link\" data-issue-key=\"CURATOR-128\"><del>CURATOR-128</del></a>: access root node within a namespace; more lenient ZKPaths.makePath.</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710485/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604708941","html_url":"https://github.com/apache/curator/issues/640#issuecomment-2604708941","issue_url":"https://api.github.com/repos/apache/curator/issues/640","id":2604708941,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDg5NDE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T02:06:34Z","updated_at":"2025-01-21T13:16:22Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user asfgit closed the pull request at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/15\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/15</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604708941/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50568177","html_url":"https://github.com/apache/curator/pull/25#issuecomment-50568177","issue_url":"https://api.github.com/repos/apache/curator/issues/25","id":50568177,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNTY4MTc3","user":{"login":"cammckenzie","id":7763121,"node_id":"MDQ6VXNlcjc3NjMxMjE=","avatar_url":"https://avatars.githubusercontent.com/u/7763121?v=4","gravatar_id":"","url":"https://api.github.com/users/cammckenzie","html_url":"https://github.com/cammckenzie","followers_url":"https://api.github.com/users/cammckenzie/followers","following_url":"https://api.github.com/users/cammckenzie/following{/other_user}","gists_url":"https://api.github.com/users/cammckenzie/gists{/gist_id}","starred_url":"https://api.github.com/users/cammckenzie/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cammckenzie/subscriptions","organizations_url":"https://api.github.com/users/cammckenzie/orgs","repos_url":"https://api.github.com/users/cammckenzie/repos","events_url":"https://api.github.com/users/cammckenzie/events{/privacy}","received_events_url":"https://api.github.com/users/cammckenzie/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T02:59:06Z","updated_at":"2014-07-30T02:59:06Z","author_association":"CONTRIBUTOR","body":"LGTM\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50568177/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710488","html_url":"https://github.com/apache/curator/issues/649#issuecomment-2604710488","issue_url":"https://api.github.com/repos/apache/curator/issues/649","id":2604710488,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA0ODg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T02:59:11Z","updated_at":"2025-01-21T13:17:00Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user cammckenzie commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/25#issuecomment-50568177\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/25#issuecomment-50568177</a></p>\n\n<p>    LGTM</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710488/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604691051","html_url":"https://github.com/apache/curator/issues/527#issuecomment-2604691051","issue_url":"https://api.github.com/repos/apache/curator/issues/527","id":2604691051,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTEwNTE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T16:56:10Z","updated_at":"2025-01-21T13:08:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user madrob opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/26\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/26</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-6\" title=\"JavaDoc in com.netflix.curator.framework.state.ConnectionState isn&#39;t clear\" class=\"issue-link\" data-issue-key=\"CURATOR-6\"><del>CURATOR-6</del></a> Add javadoc for ConenctionState</p>\n\n<p>    Add possibility to go LOST -> RECONNECTED to ConnectionState JavaDoc</p>\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/madrob/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/madrob/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-6\" title=\"JavaDoc in com.netflix.curator.framework.state.ConnectionState isn&#39;t clear\" class=\"issue-link\" data-issue-key=\"CURATOR-6\"><del>CURATOR-6</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/26.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/26.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #26</p>\n\n<hr />\n<p>commit aacdda3e155b70016f26c14bff01bfb329b14b2b<br/>\nAuthor: Mike Drob <mdrob@cloudera.com><br/>\nDate:   2014-07-30T16:55:12Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-6\" title=\"JavaDoc in com.netflix.curator.framework.state.ConnectionState isn&#39;t clear\" class=\"issue-link\" data-issue-key=\"CURATOR-6\"><del>CURATOR-6</del></a> Add javadoc for ConenctionState</p>\n\n<p>    Add possibility to go LOST -> RECONNECTED to ConnectionState JavaDoc</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604691051/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604691284","html_url":"https://github.com/apache/curator/issues/528#issuecomment-2604691284","issue_url":"https://api.github.com/repos/apache/curator/issues/528","id":2604691284,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTEyODQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T16:57:58Z","updated_at":"2025-01-21T13:08:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>This patch has been sitting in limbo for over a year now. Is it still an issue? If so, I can do the housekeeping necessary on the patch.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604691284/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604691292","html_url":"https://github.com/apache/curator/issues/528#issuecomment-2604691292","issue_url":"https://api.github.com/repos/apache/curator/issues/528","id":2604691292,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTEyOTI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T17:00:09Z","updated_at":"2025-01-21T13:08:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>We're trying to keep up. For most of Curator's life I was the only active committer. We're get more committers, but any help you can provide would be appreciated.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604691292/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710492","html_url":"https://github.com/apache/curator/issues/649#issuecomment-2604710492","issue_url":"https://api.github.com/repos/apache/curator/issues/649","id":2604710492,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA0OTI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T17:23:12Z","updated_at":"2025-01-21T13:17:00Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>I ran all the tests with this branch and they all passed.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710492/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710499","html_url":"https://github.com/apache/curator/issues/649#issuecomment-2604710499","issue_url":"https://api.github.com/repos/apache/curator/issues/649","id":2604710499,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA0OTk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T18:09:50Z","updated_at":"2025-01-21T13:17:00Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user asfgit closed the pull request at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/25\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/25</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710499/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604691296","html_url":"https://github.com/apache/curator/issues/528#issuecomment-2604691296","issue_url":"https://api.github.com/repos/apache/curator/issues/528","id":2604691296,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTEyOTY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T18:35:53Z","updated_at":"2025-01-21T13:08:46Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>Attaching a version of Shevek's patch against the apache code base. It looks like it depends on ZK-3.5, based on his original naming, so it does not compile as applied to master. I have not looked at it in enough detail to figure out if that is something that can be aligned with ZK-3.4 or not.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604691296/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604691057","html_url":"https://github.com/apache/curator/issues/527#issuecomment-2604691057","issue_url":"https://api.github.com/repos/apache/curator/issues/527","id":2604691057,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTEwNTc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-30T20:10:40Z","updated_at":"2025-01-21T13:08:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user asfgit closed the pull request at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/26\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/26</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604691057/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50753006","html_url":"https://github.com/apache/curator/pull/27#issuecomment-50753006","issue_url":"https://api.github.com/repos/apache/curator/issues/27","id":50753006,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNzUzMDA2","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T12:44:48Z","updated_at":"2014-07-31T12:44:48Z","author_association":"MEMBER","body":"I don't understand this. This would break major Curator functionality.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50753006/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695637","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695637","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695637,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2Mzc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:03:06Z","updated_at":"2025-01-21T13:10:39Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15640127\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15640127</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    What's the status of this TODO? Does it still need to be handled?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695637/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50755861","html_url":"https://github.com/apache/curator/pull/27#issuecomment-50755861","issue_url":"https://api.github.com/repos/apache/curator/issues/27","id":50755861,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNzU1ODYx","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:08:42Z","updated_at":"2014-07-31T13:08:42Z","author_association":"MEMBER","body":"Also, what Curator issue does this address?\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50755861/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695643","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695643","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695643,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2NDM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:30:39Z","updated_at":"2025-01-21T13:10:39Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15641326\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15641326</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCacheEvent.java &#8212;<br/>\n    @@ -0,0 +1,126 @@<br/>\n    +/**<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    This is just a copy of TreeCacheEvent with some naming changes right? Can't PathChildrenCacheEvent be used instead? Or, maybe we should introduce a new common class and deprecate PathChildrenCacheEvent?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695643/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695648","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695648","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695648,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2NDg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:34:00Z","updated_at":"2025-01-21T13:10:39Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15641489\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15641489</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +</p>\n{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}\n<p>    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    stat.set(event.getStat());<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}\n<p>    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.getAndSet(event.getStat());<br/>\n    +    if ( cacheData )<br/>\n    +    </p>\n{\n    +data.set(event.getData());\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +    else if ( oldStat.getMzxid() != event.getStat().getMzxid() )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}\n<p>    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED) )<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    setting treeState to start here means that TreeCache.start() can be called multiple times without error.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695648/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695653","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695653","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695653,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2NTM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:35:05Z","updated_at":"2025-01-21T13:10:40Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15641543\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15641543</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +</p>\n{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}\n<p>    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    stat.set(event.getStat());<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}\n<p>    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.getAndSet(event.getStat());<br/>\n    +    if ( cacheData )<br/>\n    +    </p>\n{\n    +data.set(event.getData());\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +    else if ( oldStat.getMzxid() != event.getStat().getMzxid() )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}\n<p>    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED) )<br/>\n    +</p>\n{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    </p>\n{\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }\n<p>    +<br/>\n    +    /**<br/>\n    +     * Detemines when to publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +</p>\n{\n    +    handleStateChange(newState);\n    +}\n<p>    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    </p>\n{\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }\n<p>    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    </p>\n{\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }\n<p>    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    </p>\n{\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }\n<p>    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    </p>\n{\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }\n<p>    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    </p>\n{\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }\n<p>    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    </p>\n{\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }\n<p>    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache<br/>\n    +     *<br/>\n    +     * @throws java.io.IOException errors<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close() throws IOException<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Doesn't need to throw IOException</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695653/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695659","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695659","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695659,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2NTk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:36:46Z","updated_at":"2025-01-21T13:10:40Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15641748\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15641748</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    stat.set(event.getStat());<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.getAndSet(event.getStat());<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }<br/>\n    +    else if ( oldStat.getMzxid() != event.getStat().getMzxid() )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Detemines when to publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache<br/>\n    +     *<br/>\n    +     * @throws java.io.IOException errors<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close() throws IOException<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    List<String> split = ZKPaths.split(fullPath.substring(root.path.length()));<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}\n<p>    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. The data is returned in sorted order. If there is<br/>\n    +     * no child with that path, <code>null</code> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public SortedSet<String> getCurrentChildren(String fullPath)<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Returning SortedSet seems too specific. In Curator, the most general interface is preferred. In this case, returning Collection<String> would be better.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695659/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695668","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695668","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695668,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2Njg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:37:16Z","updated_at":"2025-01-21T13:10:40Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15641775\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15641775</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    can be private</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695668/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695673","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695673","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695673,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2NzM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:37:25Z","updated_at":"2025-01-21T13:10:40Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15641784\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15641784</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    can be private</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695673/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695677","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695677","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695677,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2Nzc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:38:12Z","updated_at":"2025-01-21T13:10:40Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15641822\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15641822</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    stat.set(event.getStat());<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.getAndSet(event.getStat());<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }<br/>\n    +    else if ( oldStat.getMzxid() != event.getStat().getMzxid() )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Detemines when to publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache<br/>\n    +     *<br/>\n    +     * @throws java.io.IOException errors<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close() throws IOException<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    List<String> split = ZKPaths.split(fullPath.substring(root.path.length()));<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. The data is returned in sorted order. If there is<br/>\n    +     * no child with that path, <code>null</code> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public SortedSet<String> getCurrentChildren(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +{    +    return null;    +}\n<p>    +ConcurrentMap<String, TreeNode> map = node.children.get();<br/>\n    +SortedSet<String> result;<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    result = ImmutableSortedSet.of();\n    +}\n<p>    +else<br/>\n    +</p>\n{\n    +    result = ImmutableSortedSet.copyOf(map.keySet());\n    +}\n<p>    +<br/>\n    +// Double-check liveness after retreiving children.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current data for the given path. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. If there is no child with that path,<br/>\n    +     * <code>null</code> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return data if the node is alive, or null<br/>\n    +     */<br/>\n    +    public ChildData getCurrentData(String fullPath)<br/>\n    +    {<br/>\n    +TreeNode node = find(fullPath);<br/>\n    +if ( node == null || node.nodeState.get() != NodeState.LIVE )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +ChildData result = new ChildData(node.path, node.stat.get(), node.data.get());<br/>\n    +// Double-check liveness after retreiving stat / data.<br/>\n    +return node.nodeState.get() == NodeState.LIVE ? result : null;<br/>\n    +    }<br/>\n    +<br/>\n    +    void callListeners(final TreeCacheEvent event)<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    can be private</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695677/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695681","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695681","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695681,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2ODE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:43:25Z","updated_at":"2025-01-21T13:10:40Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15642130\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15642130</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +</p>\n{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}\n<p>    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    stat.set(event.getStat());<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}\n<p>    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.getAndSet(event.getStat());<br/>\n    +    if ( cacheData )<br/>\n    +    </p>\n{\n    +data.set(event.getData());\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +    else if ( oldStat.getMzxid() != event.getStat().getMzxid() )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}\n<p>    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED) )<br/>\n    +</p>\n{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    </p>\n{\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }\n<p>    +<br/>\n    +    /**<br/>\n    +     * Detemines when to publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    given that this is only used for the initialized event a better name would help. I was confused at first. Maybe \"outstandingInitializeOps\"</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695681/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695689","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695689","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695689,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2ODk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T13:49:42Z","updated_at":"2025-01-21T13:10:40Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15642588\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15642588</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    I believe wasReconnected() can be called for any use of wasCreated(). Right?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695689/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695695","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695695","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695695,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU2OTU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T17:59:13Z","updated_at":"2025-01-21T13:10:40Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15658282\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15658282</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +{<br/>\n    +case NodeCreated:<br/>\n    +    assert parent == null;<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Use Guava Preconditions instead with a reasonable message</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695695/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50797741","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50797741","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50797741,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNzk3NzQx","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T18:18:30Z","updated_at":"2014-07-31T18:18:30Z","author_association":"MEMBER","body":"There is a tiny potential for a race with outstandingOps for refreshData()'s background result to succeed before refreshChildren() resulting in a false INITIALIZED event. I was able to simulate this by forcing refreshChildren() to block indefinitely.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50797741/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695705","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695705","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695705,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3MDU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T18:18:36Z","updated_at":"2025-01-21T13:10:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50797741\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50797741</a></p>\n\n<p>    There is a tiny potential for a race with outstandingOps for refreshData()'s background result to succeed before refreshChildren() resulting in a false INITIALIZED event. I was able to simulate this by forcing refreshChildren() to block indefinitely.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695705/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50798327","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50798327","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50798327,"node_id":"MDEyOklzc3VlQ29tbWVudDUwNzk4MzI3","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T18:23:04Z","updated_at":"2014-07-31T18:32:19Z","author_association":"MEMBER","body":"I need to spend more time on this, but I'm suspecting that the refresh_() and was_() methods of TreeNode need to be synchronized. These methods can be called from the watcher/async callbacks as well as Curator's connection state listener callback. The watcher/async are from a single thread in ZK, but Curator's connection state listener callback is a different thread. Thus, these methods could be called at the same time from two threads (via wasReconnected()).\n\nA possibility is to normalize TreeNode operation into its own thread that can be signaled to operate from other threads. This is how PathChildrenCache works. However, there's a gaping hole that I just discovered (two of the constructors can be used to break PathChildrenCache).\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50798327/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695709","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695709","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695709,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3MDk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T18:23:12Z","updated_at":"2025-01-21T13:10:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50798327\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50798327</a></p>\n\n<p>    I need to spend more time on this, but I'm suspecting that the refresh*() and was*() methods of TreeNode need to be synchronized. These methods can be called from the watcher/async callbacks as well as Curator's connection state listener callback. The watcher/async are from a single thread in ZK, but Curator's connection state listener callback is a different thread. Thus, these methods could be called at the same time from two threads (via wasReconnected()).</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695709/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710585","html_url":"https://github.com/apache/curator/issues/650#issuecomment-2604710585","issue_url":"https://api.github.com/repos/apache/curator/issues/650","id":2604710585,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA1ODU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T18:35:21Z","updated_at":"2025-01-21T13:17:03Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>Alternatively, those two ctors could be made private</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710585/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710718","html_url":"https://github.com/apache/curator/issues/651#issuecomment-2604710718","issue_url":"https://api.github.com/repos/apache/curator/issues/651","id":2604710718,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA3MTg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T20:10:41Z","updated_at":"2025-01-21T13:17:07Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user madrob opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/28\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/28</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-130\" title=\"Some examples may throw NPE on end of input\" class=\"issue-link\" data-issue-key=\"CURATOR-130\"><del>CURATOR-130</del></a> Add null check to input processing.</p>\n\n\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/madrob/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/madrob/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-130\" title=\"Some examples may throw NPE on end of input\" class=\"issue-link\" data-issue-key=\"CURATOR-130\"><del>CURATOR-130</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/28.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/28.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #28</p>\n\n<hr />\n<p>commit f5767c8909d25761fcc5ed1a8f462fb8f0533487<br/>\nAuthor: Mike Drob <mdrob@cloudera.com><br/>\nDate:   2014-07-31T20:10:17Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-130\" title=\"Some examples may throw NPE on end of input\" class=\"issue-link\" data-issue-key=\"CURATOR-130\"><del>CURATOR-130</del></a> Add null check to input processing.</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710718/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710725","html_url":"https://github.com/apache/curator/issues/651#issuecomment-2604710725","issue_url":"https://api.github.com/repos/apache/curator/issues/651","id":2604710725,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA3MjU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T21:06:23Z","updated_at":"2025-01-21T13:17:07Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user asfgit closed the pull request at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/28\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/28</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710725/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710862","html_url":"https://github.com/apache/curator/issues/652#issuecomment-2604710862","issue_url":"https://api.github.com/repos/apache/curator/issues/652","id":2604710862,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTA4NjI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T21:25:47Z","updated_at":"2025-01-21T13:17:10Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user madrob opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/29\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/29</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-131\" title=\"Should not modify collection while iterating over it\" class=\"issue-link\" data-issue-key=\"CURATOR-131\"><del>CURATOR-131</del></a> use iterator.remove instead of foreach</p>\n\n<p>    When iterating over a collection, if we try to remove elements that<br/>\n    can lead to undefined behaviour. We should use an iterator and its<br/>\n    remove method to do this safely.</p>\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/madrob/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/madrob/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-131\" title=\"Should not modify collection while iterating over it\" class=\"issue-link\" data-issue-key=\"CURATOR-131\"><del>CURATOR-131</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/29.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/29.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #29</p>\n\n<hr />\n<p>commit e38d1ceda492e097ad9c94bb854838f2b1f7caa9<br/>\nAuthor: Mike Drob <mdrob@cloudera.com><br/>\nDate:   2014-07-31T21:24:40Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-131\" title=\"Should not modify collection while iterating over it\" class=\"issue-link\" data-issue-key=\"CURATOR-131\"><del>CURATOR-131</del></a> use iterator.remove instead of foreach</p>\n\n<p>    When iterating over a collection, if we try to remove elements that<br/>\n    can lead to undefined behaviour. We should use an iterator and its<br/>\n    remove method to do this safely.</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604710862/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695716","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695716","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695716,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3MTY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T22:26:48Z","updated_at":"2025-01-21T13:10:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15673864\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15673864</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    sure thing, my personal style is typically not to bother marking inner classes private since it makes javac emit package-access bridge methods to allow the outer class to access the inner class, but i'm sure it makes little actual difference so happy to add if that's the preferred style</p>\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695716/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695730","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695730","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695730,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3MzA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T22:29:40Z","updated_at":"2025-01-21T13:10:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15673959\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15673959</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Technically, yes, since childMap will be null when the node wasCreate().  But doesn't this seem a little more readable for a tiny bit of extra code?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695730/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695735","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695735","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695735,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3MzU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T22:31:04Z","updated_at":"2025-01-21T13:10:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15674008\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15674008</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    changed to checkState as above</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695735/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695742","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695742","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695742,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3NDI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T22:32:09Z","updated_at":"2025-01-21T13:10:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15674042\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15674042</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +</p>\n{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}\n<p>    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    stat.set(event.getStat());<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}\n<p>    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.getAndSet(event.getStat());<br/>\n    +    if ( cacheData )<br/>\n    +    </p>\n{\n    +data.set(event.getData());\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +    else if ( oldStat.getMzxid() != event.getStat().getMzxid() )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}\n<p>    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED) )<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    To be clear, you want to enforce that start() cannot be called multiple times?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695742/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695748","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695748","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695748,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3NDg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T22:35:56Z","updated_at":"2025-01-21T13:10:41Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15674181\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15674181</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +</p>\n{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}\n<p>    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    stat.set(event.getStat());<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}\n<p>    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.getAndSet(event.getStat());<br/>\n    +    if ( cacheData )<br/>\n    +    </p>\n{\n    +data.set(event.getData());\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +    else if ( oldStat.getMzxid() != event.getStat().getMzxid() )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}\n<p>    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED) )<br/>\n    +</p>\n{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    </p>\n{\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }\n<p>    +<br/>\n    +    /**<br/>\n    +     * Detemines when to publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Good point.  We do continue tracking this, however, even after we're initialized.  Maybe more clear javadoc?  Like:</p>\n\n<p>    \"Tracks the number of outstanding background requests in flight.  The first time this count reaches 0, we publish the initialized event.\"</p>\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695748/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695753","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695753","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695753,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3NTM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T22:48:55Z","updated_at":"2025-01-21T13:10:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15674624\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15674624</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,600 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    System.out.println(event);<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    System.out.println(event);<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    stat.set(event.getStat());<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{<br/>\n    +    TreeNode node = new TreeNode(fullPath, this);<br/>\n    +    if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +    {\n    +node.wasCreated();\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.getAndSet(event.getStat());<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }<br/>\n    +    else if ( oldStat.getMzxid() != event.getStat().getMzxid() )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Detemines when to publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache<br/>\n    +     *<br/>\n    +     * @throws java.io.IOException errors<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close() throws IOException<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    List<String> split = ZKPaths.split(fullPath.substring(root.path.length()));<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}\n<p>    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. The data is returned in sorted order. If there is<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    I went ahead and changed this to return `SortedMap<String, ChildData>` to return both the names and data of all current children.  I will add another accessor to return an entire subtree so I can document that it might be expensive.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695753/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695755","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695755","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695755,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3NTU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T22:50:41Z","updated_at":"2025-01-21T13:10:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15675036\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15675036</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    stat.set(event.getStat());<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}<br/>\n    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.getAndSet(event.getStat());<br/>\n    +    if ( cacheData )<br/>\n    +    {\n    +data.set(event.getData());\n    +    }<br/>\n    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }<br/>\n    +    else if ( oldStat.getMzxid() != event.getStat().getMzxid() )<br/>\n    +    {\n    +publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED) )<br/>\n    +{\n    +    publishEvent(TreeCacheEvent.Type.INITIALIZED);\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    private enum TreeState<br/>\n    +    {\n    +LATENT,\n    +STARTED,\n    +CLOSED\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Detemines when to publish the initialized event.<br/>\n    +     */<br/>\n    +    private final AtomicLong outstandingOps = new AtomicLong(0);<br/>\n    +<br/>\n    +    private final TreeNode root;<br/>\n    +    private final CuratorFramework client;<br/>\n    +    private final CloseableExecutorService executorService;<br/>\n    +    private final boolean cacheData;<br/>\n    +    private final boolean dataIsCompressed;<br/>\n    +    private final ListenerContainer<TreeCacheListener> listeners = new ListenerContainer<TreeCacheListener>();<br/>\n    +    private final AtomicReference<TreeState> treeState = new AtomicReference<TreeState>(TreeState.LATENT);<br/>\n    +<br/>\n    +    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()<br/>\n    +    {<br/>\n    +@Override<br/>\n    +public void stateChanged(CuratorFramework client, ConnectionState newState)<br/>\n    +{\n    +    handleStateChange(newState);\n    +}<br/>\n    +    };<br/>\n    +<br/>\n    +    private static final ThreadFactory defaultThreadFactory = ThreadUtils.newThreadFactory(\"TreeCache\");<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client    the client<br/>\n    +     * @param path      path to watch<br/>\n    +     * @param cacheData if true, node contents are cached in addition to the stat<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(defaultThreadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param clientthe client<br/>\n    +     * @param path  path to watch<br/>\n    +     * @param cacheData     if true, node contents are cached in addition to the stat<br/>\n    +     * @param threadFactory factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, false, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param threadFactory    factory to use when creating internal threads<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory), true));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final ExecutorService executorService)<br/>\n    +    {\n    +this(client, path, cacheData, dataIsCompressed, new CloseableExecutorService(executorService));\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * @param client   the client<br/>\n    +     * @param path     path to watch<br/>\n    +     * @param cacheDataif true, node contents are cached in addition to the stat<br/>\n    +     * @param dataIsCompressed if true, data in the path is compressed<br/>\n    +     * @param executorService  Closeable ExecutorService to use for the TreeCache's background thread<br/>\n    +     */<br/>\n    +    public TreeCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, final CloseableExecutorService executorService)<br/>\n    +    {\n    +this.root = new TreeNode(path, null);\n    +this.client = client;\n    +this.cacheData = cacheData;\n    +this.dataIsCompressed = dataIsCompressed;\n    +this.executorService = executorService;\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Start the cache. The cache is not started automatically. You must call this method.<br/>\n    +     *<br/>\n    +     * @throws Exception errors<br/>\n    +     */<br/>\n    +    public void start() throws Exception<br/>\n    +    {\n    +client.getConnectionStateListenable().addListener(connectionStateListener);\n    +root.wasCreated();\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Close/end the cache<br/>\n    +     *<br/>\n    +     * @throws java.io.IOException errors<br/>\n    +     */<br/>\n    +    @Override<br/>\n    +    public void close() throws IOException<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED) )<br/>\n    +{<br/>\n    +    client.getConnectionStateListenable().removeListener(connectionStateListener);<br/>\n    +    listeners.clear();<br/>\n    +    executorService.close();<br/>\n    +    try<br/>\n    +    {\n    +root.wasDeleted();\n    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    {    +handleException(e);    +    }\n<p>    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the cache listenable<br/>\n    +     *<br/>\n    +     * @return listenable<br/>\n    +     */<br/>\n    +    public ListenerContainer<TreeCacheListener> getListenable()<br/>\n    +    </p>\n{\n    +return listeners;\n    +    }\n<p>    +<br/>\n    +    private TreeNode find(String fullPath)<br/>\n    +    {<br/>\n    +if ( !fullPath.startsWith(root.path) )<br/>\n    +</p>\n{\n    +    return null;\n    +}\n<p>    +<br/>\n    +TreeNode current = root;<br/>\n    +if ( fullPath.length() > root.path.length() )<br/>\n    +{<br/>\n    +    List<String> split = ZKPaths.split(fullPath.substring(root.path.length()));<br/>\n    +    for ( String part : split )<br/>\n    +    {<br/>\n    +ConcurrentMap<String, TreeNode> map = current.children.get();<br/>\n    +if ( map == null )<br/>\n    +</p>\n{\n    +    return null;\n    +}<br/>\n    +current = map.get(part);<br/>\n    +if ( current == null )<br/>\n    +{    +    return null;    +}\n<p>    +    }<br/>\n    +}<br/>\n    +return current;<br/>\n    +    }<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Return the current set of children. There are no guarantees of accuracy. This is<br/>\n    +     * merely the most recent view of the data. The data is returned in sorted order. If there is<br/>\n    +     * no child with that path, <code>null</code> is returned.<br/>\n    +     *<br/>\n    +     * @param fullPath full path to the node to check<br/>\n    +     * @return a possibly-empty list of children if the node is alive, or null<br/>\n    +     */<br/>\n    +    public SortedSet<String> getCurrentChildren(String fullPath)<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Gotcha.  In my working copy I have this as `SortedMap<String, ChildData>` but I could loosen to `Map<String, ChildData>`.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695755/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695759","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695759","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695759,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3NTk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T22:59:47Z","updated_at":"2025-01-21T13:10:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15675387\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15675387</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCacheEvent.java &#8212;<br/>\n    @@ -0,0 +1,126 @@<br/>\n    +/**<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Glad you brought this up; it's a straight copy, I think the only changes are renaming things like CHILD_ADDED -> NODE_ADDED.  I tried to consistently switch to \"node\" terminology since nodes in the tree cache can be both parents and children (as opposed to PathChildrenCache).  Also, I wasn't sure how weird it would be to have a TreeCache emitting PathChildrenCacheEvents.</p>\n\n<p>    I do kind of like the idea of deprecating the old event interfaces and creating a new one that can consistently surface events for all 3 caches.  Perhaps we could call it \"CacheEvent\" and it would essentially look like TreeCacheEvent.  I think NodeCache would be especially improved by this, since at the moment all it offers is a \"nodeChanged\" event.</p>\n\n<p>    The caches could simply keep two lists of listeners and publish both new and old style events.</p>\n\n<p>    What do you think?</p>\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695759/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695764","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695764","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695764,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3NjQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T23:08:19Z","updated_at":"2025-01-21T13:10:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15675713\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15675713</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCacheEvent.java &#8212;<br/>\n    @@ -0,0 +1,126 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +/**<br/>\n    + * POJO that abstracts a change to a path<br/>\n    + */<br/>\n    +public class TreeCacheEvent<br/>\n    +{<br/>\n    +    private final Type type;<br/>\n    +    private final ChildData data;<br/>\n    +<br/>\n    +    /**<br/>\n    +     * Type of change<br/>\n    +     */<br/>\n    +    public enum Type<br/>\n    +    {<br/>\n    +/**<br/>\n    + * A node was added.<br/>\n    + */<br/>\n    +NODE_ADDED,<br/>\n    +<br/>\n    +/**<br/>\n    + * A node's data was changed<br/>\n    + */<br/>\n    +NODE_UPDATED,<br/>\n    +<br/>\n    +/**<br/>\n    + * A node was removed from the tree<br/>\n    + */<br/>\n    +NODE_REMOVED,<br/>\n    +<br/>\n    +/**<br/>\n    + * Called when the connection has changed to </p>\n{@link org.apache.curator.framework.state.ConnectionState#SUSPENDED}\n<p>    + * <p/><br/>\n    + * This is exposed so that users of the class can be notified of issues that <b>might</b> affect normal operation.<br/>\n    + * The TreeCache is written such that listeners are not expected to do anything special on this<br/>\n    + * event, except for those people who want to cause some application-specific logic to fire when this occurs.<br/>\n    + * While the connection is down, the TreeCache will continue to have its state from before it lost<br/>\n    + * the connection and after the connection is restored, the TreeCache will emit normal child events<br/>\n    + * for all of the adds, deletes and updates that happened during the time that it was disconnected.<br/>\n    + */<br/>\n    +CONNECTION_SUSPENDED,<br/>\n    +<br/>\n    +/**<br/>\n    + * Called when the connection has changed to </p>\n{@link org.apache.curator.framework.state.ConnectionState#RECONNECTED}\n<p>    + * <p/><br/>\n    + * This is exposed so that users of the class can be notified of issues that <b>might</b> affect normal operation.<br/>\n    + * The TreeCache is written such that listeners are not expected to do anything special on this<br/>\n    + * event, except for those people who want to cause some application-specific logic to fire when this occurs.<br/>\n    + * While the connection is down, the TreeCache will continue to have its state from before it lost<br/>\n    + * the connection and after the connection is restored, the TreeCache will emit normal child events<br/>\n    + * for all of the adds, deletes and updates that happened during the time that it was disconnected.<br/>\n    + */<br/>\n    +CONNECTION_RECONNECTED,<br/>\n    +<br/>\n    +/**<br/>\n    + * Called when the connection has changed to </p>\n{@link org.apache.curator.framework.state.ConnectionState#LOST}\n<p>    + * <p/><br/>\n    + * This is exposed so that users of the class can be notified of issues that <b>might</b> affect normal operation.<br/>\n    + * The TreeCache is written such that listeners are not expected to do anything special on this<br/>\n    + * event, except for those people who want to cause some application-specific logic to fire when this occurs.<br/>\n    + * While the connection is down, the TreeCache will continue to have its state from before it lost<br/>\n    + * the connection and after the connection is restored, the TreeCache will emit normal child events<br/>\n    + * for all of the adds, deletes and updates that happened during the time that it was disconnected.<br/>\n    + */<br/>\n    +CONNECTION_LOST,<br/>\n    +<br/>\n    +/**<br/>\n    + * Posted when the initial cache has been populated.<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    update doc</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695764/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711011","html_url":"https://github.com/apache/curator/issues/653#issuecomment-2604711011","issue_url":"https://api.github.com/repos/apache/curator/issues/653","id":2604711011,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEwMTE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T23:44:20Z","updated_at":"2025-01-21T13:17:14Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=vines\" class=\"user-hover\" rel=\"vines\">John Vines</a>, I don't think this is an issue with the namespace facade, I think it is an issue with attempting to set an ACL twice. If you change the second <tt>setACL</tt> call to use <tt>curator</tt> instead of <tt>curator2</tt>, then it will still fail, demonstrating that it's not a namespace issue.</p>\n\n<p>Alternatively, if you change the first call to <tt>ZooDefs.Perms.ADMIN</tt>, then it will pass, even with the namespaced second call.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711011/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711017","html_url":"https://github.com/apache/curator/issues/653#issuecomment-2604711017","issue_url":"https://api.github.com/repos/apache/curator/issues/653","id":2604711017,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEwMTc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-07-31T23:51:19Z","updated_at":"2025-01-21T13:17:14Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>Wait, nevermind, I messed up something else in my test and can reproduce this.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711017/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695767","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695767","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695767,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3Njc=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T00:07:00Z","updated_at":"2025-01-21T13:10:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15677498\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15677498</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCacheEvent.java &#8212;<br/>\n    @@ -0,0 +1,126 @@<br/>\n    +/**<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    I think that would be better for users of the recipes. The downside is a lot of coupling.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695767/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695769","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695769","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695769,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3Njk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T00:07:15Z","updated_at":"2025-01-21T13:10:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15677507\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15677507</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    +</p>\n{\n    +    refreshData();\n    +    refreshChildren();\n    +}\n<p>    +<br/>\n    +private void wasDeleted() throws Exception<br/>\n    +{<br/>\n    +    stat.set(null);<br/>\n    +    data.set(null);<br/>\n    +    client.clearWatcherReferences(this);<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.getAndSet(null);<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());<br/>\n    +childMap.clear();<br/>\n    +for ( TreeNode child : childCopy )<br/>\n    +</p>\n{\n    +    child.wasDeleted();\n    +}\n<p>    +    }<br/>\n    +<br/>\n    +    if ( treeState.get() == TreeState.CLOSED )<br/>\n    +    </p>\n{\n    +return;\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.LIVE, NodeState.DEAD) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_REMOVED, path);\n    +    }\n<p>    +<br/>\n    +    if ( parent == null )<br/>\n    +    </p>\n{\n    +// Root node; use an exist query to watch for existence.\n    +client.checkExists().usingWatcher(this).inBackground().forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    {<br/>\n    +// Remove from parent if we're currently a child<br/>\n    +ConcurrentMap<String, TreeNode> parentChildMap = parent.children.get();<br/>\n    +if ( parentChildMap != null )<br/>\n    +</p>\n{\n    +    parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void process(WatchedEvent event)<br/>\n    +{<br/>\n    +    try<br/>\n    +    {<br/>\n    +switch ( event.getType() )<br/>\n    +</p>\n{\n    +case NodeCreated:\n    +    assert parent == null;\n    +    wasCreated();\n    +    break;\n    +case NodeChildrenChanged:\n    +    refreshChildren();\n    +    break;\n    +case NodeDataChanged:\n    +    refreshData();\n    +    break;\n    +case NodeDeleted:\n    +    wasDeleted();\n    +    break;\n    +}\n<p>    +    }<br/>\n    +    catch ( Exception e )<br/>\n    +    </p>\n{\n    +handleException(e);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +@Override<br/>\n    +public void processResult(CuratorFramework client, CuratorEvent event) throws Exception<br/>\n    +{<br/>\n    +    switch ( event.getType() )<br/>\n    +    {<br/>\n    +    case EXISTS:<br/>\n    +// TODO: should only happen for root node<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +</p>\n{\n    +    nodeState.compareAndSet(NodeState.DEAD, NodeState.PENDING);\n    +    wasCreated();\n    +}\n<p>    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}<br/>\n    +break;<br/>\n    +    case CHILDREN:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    stat.set(event.getStat());<br/>\n    +<br/>\n    +    if ( event.getChildren().isEmpty() )<br/>\n    +    {\n    +break;\n    +    }<br/>\n    +<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap == null )<br/>\n    +    {<br/>\n    +childMap = Maps.newConcurrentMap();<br/>\n    +if ( !children.compareAndSet(null, childMap) )<br/>\n    +{\n    +    childMap = children.get();\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    // Present new children in sorted order for test determinism.<br/>\n    +    List<String> newChildren = new ArrayList<String>();<br/>\n    +    for ( String child : event.getChildren() )<br/>\n    +    {<br/>\n    +if ( !childMap.containsKey(child) )<br/>\n    +{\n    +    newChildren.add(child);\n    +}<br/>\n    +    }<br/>\n    +<br/>\n    +    Collections.sort(newChildren);<br/>\n    +    for ( String child : newChildren )<br/>\n    +    {<br/>\n    +String fullPath = ZKPaths.makePath(path, child);<br/>\n    +TreeNode node = new TreeNode(fullPath, this);<br/>\n    +if ( childMap.putIfAbsent(child, node) == null )<br/>\n    +{\n    +    node.wasCreated();\n    +}<br/>\n    +    }<br/>\n    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +{    +    wasDeleted();    +}\n<p>    +break;<br/>\n    +    case GET_DATA:<br/>\n    +if ( event.getResultCode() == KeeperException.Code.OK.intValue() )<br/>\n    +{<br/>\n    +    Stat oldStat = stat.getAndSet(event.getStat());<br/>\n    +    if ( cacheData )<br/>\n    +    </p>\n{\n    +data.set(event.getData());\n    +    }\n<p>    +<br/>\n    +    if ( nodeState.compareAndSet(NodeState.PENDING, NodeState.LIVE) )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_ADDED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +    else if ( oldStat.getMzxid() != event.getStat().getMzxid() )<br/>\n    +    </p>\n{\n    +publishEvent(TreeCacheEvent.Type.NODE_UPDATED, new ChildData(event.getPath(), event.getStat(), event.getData()));\n    +    }\n<p>    +}<br/>\n    +else if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )<br/>\n    +</p>\n{\n    +    wasDeleted();\n    +}\n<p>    +break;<br/>\n    +    default:<br/>\n    +handleException(new Exception(String.format(\"Unknown event %s\", event)));<br/>\n    +    }<br/>\n    +<br/>\n    +    if ( outstandingOps.decrementAndGet() == 0 )<br/>\n    +    {<br/>\n    +if ( treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED) )<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Yes. </p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695769/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695774","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695774","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695774,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3NzQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T00:08:21Z","updated_at":"2025-01-21T13:10:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15677537\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15677537</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Maybe move the common two method calls into a private method. I'm just concerned about maintenance of two methods that do mostly the same thing.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695774/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50842556","html_url":"https://github.com/apache/curator/pull/27#issuecomment-50842556","issue_url":"https://api.github.com/repos/apache/curator/issues/27","id":50842556,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODQyNTU2","user":{"login":"youngwan657","id":1865655,"node_id":"MDQ6VXNlcjE4NjU2NTU=","avatar_url":"https://avatars.githubusercontent.com/u/1865655?v=4","gravatar_id":"","url":"https://api.github.com/users/youngwan657","html_url":"https://github.com/youngwan657","followers_url":"https://api.github.com/users/youngwan657/followers","following_url":"https://api.github.com/users/youngwan657/following{/other_user}","gists_url":"https://api.github.com/users/youngwan657/gists{/gist_id}","starred_url":"https://api.github.com/users/youngwan657/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/youngwan657/subscriptions","organizations_url":"https://api.github.com/users/youngwan657/orgs","repos_url":"https://api.github.com/users/youngwan657/repos","events_url":"https://api.github.com/users/youngwan657/events{/privacy}","received_events_url":"https://api.github.com/users/youngwan657/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T02:20:51Z","updated_at":"2014-08-01T02:20:51Z","author_association":"NONE","body":"I have a question.\nHow do I watch the znode again when reconnected after connection and session timeout?\nI think the application didn't know RECONNECTED state. \nTherefore the application didn't watch any change of the znode after that.\n\n[log]\nConnection attempt unsuccessful after 10205 (greater than max timeout of 10000). Resetting connection and trying again with a new connection.\nreset\nState change: RECONNECTED\nThere are no ConnectionStateListeners registered.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50842556/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50844360","html_url":"https://github.com/apache/curator/pull/27#issuecomment-50844360","issue_url":"https://api.github.com/repos/apache/curator/issues/27","id":50844360,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODQ0MzYw","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T03:00:13Z","updated_at":"2014-08-01T03:00:13Z","author_association":"MEMBER","body":"Watchers in ZooKeeper are one time only. Once the process() method is called, you need to reset the watch by calling whatever method you used originally. Alternatively, use one of the Curator recipes such as NodeCache.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50844360/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50844590","html_url":"https://github.com/apache/curator/pull/27#issuecomment-50844590","issue_url":"https://api.github.com/repos/apache/curator/issues/27","id":50844590,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODQ0NTkw","user":{"login":"youngwan657","id":1865655,"node_id":"MDQ6VXNlcjE4NjU2NTU=","avatar_url":"https://avatars.githubusercontent.com/u/1865655?v=4","gravatar_id":"","url":"https://api.github.com/users/youngwan657","html_url":"https://github.com/youngwan657","followers_url":"https://api.github.com/users/youngwan657/followers","following_url":"https://api.github.com/users/youngwan657/following{/other_user}","gists_url":"https://api.github.com/users/youngwan657/gists{/gist_id}","starred_url":"https://api.github.com/users/youngwan657/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/youngwan657/subscriptions","organizations_url":"https://api.github.com/users/youngwan657/orgs","repos_url":"https://api.github.com/users/youngwan657/repos","events_url":"https://api.github.com/users/youngwan657/events{/privacy}","received_events_url":"https://api.github.com/users/youngwan657/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T03:05:48Z","updated_at":"2014-08-01T03:07:19Z","author_association":"NONE","body":"But in this case, process() method wasn't called.  \nThe application didn't detect any event.  \n\nThat log is curator log not application log.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50844590/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50844642","html_url":"https://github.com/apache/curator/pull/27#issuecomment-50844642","issue_url":"https://api.github.com/repos/apache/curator/issues/27","id":50844642,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODQ0NjQy","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T03:07:07Z","updated_at":"2014-08-01T03:07:07Z","author_association":"MEMBER","body":"You can look at various Curator recipes. Generally, when RECONNECTED is received, Curator recipes reset whatever watchers are needed.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50844642/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50851793","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50851793","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50851793,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODUxNzkz","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T06:02:32Z","updated_at":"2014-08-01T06:02:32Z","author_association":"CONTRIBUTOR","body":"Updates based on feedback; getCurrentChildren() returns a map, added more extensive testing and polish.\n\nThe one thing still missing is an accessor to get an entire subtree.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50851793/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695778","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695778","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695778,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3Nzg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T06:02:38Z","updated_at":"2025-01-21T13:10:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50851793\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50851793</a></p>\n\n<p>    Updates based on feedback; getCurrentChildren() returns a map, added more extensive testing and polish.</p>\n\n<p>    The one thing still missing is an accessor to get an entire subtree.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695778/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711153","html_url":"https://github.com/apache/curator/issues/654#issuecomment-2604711153","issue_url":"https://api.github.com/repos/apache/curator/issues/654","id":2604711153,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTExNTM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T07:20:52Z","updated_at":"2025-01-21T13:17:17Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cammckenzie\">cammckenzie</a>:</i>\n<p>Can you provide a test case to reproduce the issue?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711153/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711020","html_url":"https://github.com/apache/curator/issues/653#issuecomment-2604711020","issue_url":"https://api.github.com/repos/apache/curator/issues/653","id":2604711020,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTEwMjA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T07:52:06Z","updated_at":"2025-01-21T13:17:14Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cammckenzie\">cammckenzie</a>:</i>\n<p>This appears to happen because setACL() is overridden in the NamespaceFacade to use the underlying CuratorFrameworkImpl.</p>\n\n<p>i.e.</p>\n\n<p>@Override<br/>\n    public SetACLBuilder setACL()</p>\n    {\nreturn client.setACL();\n    }\n\n<p>This means that the namespace information in the facade gets lost when ACLing via a NamespaceFacade. I will look into if removing this override (and the one for getACL()) breaks anything else, as I presume these were overridden for a reason.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711020/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50882098","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50882098","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50882098,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODgyMDk4","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T13:13:14Z","updated_at":"2014-08-01T13:13:14Z","author_association":"MEMBER","body":"OK - please reply to the race issues mentioned above.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50882098/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695786","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695786","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695786,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3ODY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T13:13:23Z","updated_at":"2025-01-21T13:10:42Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50882098\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50882098</a></p>\n\n<p>    OK - please reply to the race issues mentioned above.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695786/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695790","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695790","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695790,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3OTA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T13:44:07Z","updated_at":"2025-01-21T13:10:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user jhump commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15696190\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15696190</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    The class can still be private. The synthetic methods are only added for private methods, fields, and constructors. So you can mark the class as private, leave its members as package-private, and there shouldn't be any synthetic accessors.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695790/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50885633","html_url":"https://github.com/apache/curator/pull/16#issuecomment-50885633","issue_url":"https://api.github.com/repos/apache/curator/issues/16","id":50885633,"node_id":"MDEyOklzc3VlQ29tbWVudDUwODg1NjMz","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T13:47:13Z","updated_at":"2014-08-01T13:47:13Z","author_association":"MEMBER","body":"Is this still needed? If so, there should be a backwards compatible change.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50885633/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604709122","html_url":"https://github.com/apache/curator/issues/641#issuecomment-2604709122","issue_url":"https://api.github.com/repos/apache/curator/issues/641","id":2604709122,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDkxMjI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T13:47:19Z","updated_at":"2025-01-21T13:16:27Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/16#issuecomment-50885633\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/16#issuecomment-50885633</a></p>\n\n<p>    Is this still needed? If so, there should be a backwards compatible change.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604709122/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711160","html_url":"https://github.com/apache/curator/issues/654#issuecomment-2604711160","issue_url":"https://api.github.com/repos/apache/curator/issues/654","id":2604711160,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTExNjA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T14:48:56Z","updated_at":"2025-01-21T13:17:18Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=vines\">vines</a>:</i>\n<p>Hmm... must have been PEBCAK, I have it working now.</p>\n\n<p>Though it is a bit confusing that NodeCache.geturrentData.getPath returns the non-namespaced path</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711160/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711162","html_url":"https://github.com/apache/curator/issues/654#issuecomment-2604711162","issue_url":"https://api.github.com/repos/apache/curator/issues/654","id":2604711162,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTExNjI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T14:52:04Z","updated_at":"2025-01-21T13:17:18Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>NodeCache.geturrentData.getPath returns the non-namespaced path. If it does I'd consider that a bug. A really bad bug. I'm going to double check that. If it's true, it will be nearly impossible to fix in a backward compatible way. </p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711162/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711170","html_url":"https://github.com/apache/curator/issues/654#issuecomment-2604711170","issue_url":"https://api.github.com/repos/apache/curator/issues/654","id":2604711170,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTExNzA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T14:57:09Z","updated_at":"2025-01-21T13:17:18Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=randgalt\">randgalt</a>:</i>\n<p>I just did a test and getCurrentData().getPath() returns the correct namespaced path. Can you produce a test?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711170/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711175","html_url":"https://github.com/apache/curator/issues/654#issuecomment-2604711175","issue_url":"https://api.github.com/repos/apache/curator/issues/654","id":2604711175,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MTExNzU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T15:08:18Z","updated_at":"2025-01-21T13:17:18Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=vines\">vines</a>:</i>\n<p>I mean non-namespace adjusted path.</p>\n\n<p>Though it make sense the way it behaves now.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604711175/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700881","html_url":"https://github.com/apache/curator/issues/588#issuecomment-2604700881","issue_url":"https://api.github.com/repos/apache/curator/issues/588","id":2604700881,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDA4ODE=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T16:31:20Z","updated_at":"2025-01-21T13:12:55Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user madrob opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/30\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/30</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-67\" title=\"Issue with default JSONInstanceSerializer for discovery service builder\" class=\"issue-link\" data-issue-key=\"CURATOR-67\"><del>CURATOR-67</del></a> defer creation of serializer</p>\n\n<p>    Instead of immediately creating a new JSONInstanceSerializer we can<br/>\n    defer until build() is actually called. This lets users specify their<br/>\n    own serializers and avoids issues where there may be version conflicts.</p>\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/madrob/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/madrob/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-67\" title=\"Issue with default JSONInstanceSerializer for discovery service builder\" class=\"issue-link\" data-issue-key=\"CURATOR-67\"><del>CURATOR-67</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/30.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/30.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #30</p>\n\n<hr />\n<p>commit f24e11bdc9ca45e94479b1c6fc981b8b7393f619<br/>\nAuthor: Mike Drob <mdrob@cloudera.com><br/>\nDate:   2014-08-01T16:29:30Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-67\" title=\"Issue with default JSONInstanceSerializer for discovery service builder\" class=\"issue-link\" data-issue-key=\"CURATOR-67\"><del>CURATOR-67</del></a> defer creation of serializer</p>\n\n<p>    Instead of immediately creating a new JSONInstanceSerializer we can<br/>\n    defer until build() is actually called. This lets users specify their<br/>\n    own serializers and avoids issues where there may be version conflicts.</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700881/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700886","html_url":"https://github.com/apache/curator/issues/588#issuecomment-2604700886","issue_url":"https://api.github.com/repos/apache/curator/issues/588","id":2604700886,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDA4ODY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T16:31:35Z","updated_at":"2025-01-21T13:12:55Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>Cleaned this up, created a test, and made a pull request for it.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604700886/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701458","html_url":"https://github.com/apache/curator/issues/592#issuecomment-2604701458","issue_url":"https://api.github.com/repos/apache/curator/issues/592","id":2604701458,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDE0NTg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T17:06:22Z","updated_at":"2025-01-21T13:13:09Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mdrob\">mdrob</a>:</i>\n<p>We can expand the scope of this issue to remove all of the instances of log-and-throw. Some rationale is available at <a href=\"https://today.java.net/article/2006/04/04/exception-handling-antipatterns#logAndThrow\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://today.java.net/article/2006/04/04/exception-handling-antipatterns#logAndThrow</a></p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701458/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50913715","html_url":"https://github.com/apache/curator/pull/16#issuecomment-50913715","issue_url":"https://api.github.com/repos/apache/curator/issues/16","id":50913715,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTEzNzE1","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T17:45:11Z","updated_at":"2014-08-01T17:45:11Z","author_association":"CONTRIBUTOR","body":"Up to you guys.  I don't need it personally anymore, but if you think it would be useful, I'm happy to do the work to land it.  Let's just decide on what exactly we want.  As I mentioned, I'm loathe to add more constructor arguments as there are already so many overloads.\n\nWhat would you think about either a builder, or else a fluent constructor api?\n\nBuilder example:\n\n```\ncache = PathChildrenCache.newBuilder(client, path)\n  .ensurePath(false)\n  .cacheData(false)\n  .compress(true)\n  .withExecutor(executor)\n  .build()\ncache.start();\n```\n\nFluent constructor:\n\n```\ncache = new PathChildrenCache(client, path)\n  .ensurePath(false)\n  .cacheData(false)\n  .compress(true)\n  .withExecutor(executor)\n  .start()\n```\n\nIn this formulation, essentially the new PathChildrenCache modifies its configuration each time, returning itself, which is legal up until start() is called.  Once start() is called it's illegal state exception to try to call any of the config methods.\n\nEither way, all of the existing defaults would hold for items not specified.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50913715/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604709125","html_url":"https://github.com/apache/curator/issues/641#issuecomment-2604709125","issue_url":"https://api.github.com/repos/apache/curator/issues/641","id":2604709125,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDkxMjU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T17:45:16Z","updated_at":"2025-01-21T13:16:27Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/16#issuecomment-50913715\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/16#issuecomment-50913715</a></p>\n\n<p>    Up to you guys.  I don't need it personally anymore, but if you think it would be useful, I'm happy to do the work to land it.  Let's just decide on what exactly we want.  As I mentioned, I'm loathe to add more constructor arguments as there are already so many overloads.</p>\n\n<p>    What would you think about either a builder, or else a fluent constructor api?</p>\n\n<p>    Builder example:</p>\n\n<p>    ```<br/>\n    cache = PathChildrenCache.newBuilder(client, path)<br/>\n      .ensurePath(false)<br/>\n      .cacheData(false)<br/>\n      .compress(true)<br/>\n      .withExecutor(executor)<br/>\n      .build()<br/>\n    cache.start();<br/>\n    ```</p>\n\n<p>    Fluent constructor:</p>\n\n<p>    ```<br/>\n    cache = new PathChildrenCache(client, path)<br/>\n      .ensurePath(false)<br/>\n      .cacheData(false)<br/>\n      .compress(true)<br/>\n      .withExecutor(executor)<br/>\n      .start()<br/>\n    ```</p>\n\n<p>    In this formulation, essentially the new PathChildrenCache modifies its configuration each time, returning itself, which is legal up until start() is called.  Once start() is called it's illegal state exception to try to call any of the config methods.</p>\n\n<p>    Either way, all of the existing defaults would hold for items not specified.</p>\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604709125/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695794","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695794","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695794,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU3OTQ=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T17:46:01Z","updated_at":"2025-01-21T13:10:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on a diff in the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#discussion_r15708789\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#discussion_r15708789</a></p>\n\n<p>    &#8212; Diff: curator-recipes/src/main/java/org/apache/curator/framework/recipes/cache/TreeCache.java &#8212;<br/>\n    @@ -0,0 +1,605 @@<br/>\n    +/**<br/>\n    + * Licensed to the Apache Software Foundation (ASF) under one<br/>\n    + * or more contributor license agreements.  See the NOTICE file<br/>\n    + * distributed with this work for additional information<br/>\n    + * regarding copyright ownership.  The ASF licenses this file<br/>\n    + * to you under the Apache License, Version 2.0 (the<br/>\n    + * \"License\"); you may not use this file except in compliance<br/>\n    + * with the License.  You may obtain a copy of the License at<br/>\n    + *<br/>\n    + *   <a href=\"http://www.apache.org/licenses/LICENSE-2.0\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">http://www.apache.org/licenses/LICENSE-2.0</a><br/>\n    + *<br/>\n    + * Unless required by applicable law or agreed to in writing,<br/>\n    + * software distributed under the License is distributed on an<br/>\n    + * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY<br/>\n    + * KIND, either express or implied.  See the License for the<br/>\n    + * specific language governing permissions and limitations<br/>\n    + * under the License.<br/>\n    + */<br/>\n    +<br/>\n    +package org.apache.curator.framework.recipes.cache;<br/>\n    +<br/>\n    +import com.google.common.base.Function;<br/>\n    +import com.google.common.collect.ImmutableSortedSet;<br/>\n    +import com.google.common.collect.Maps;<br/>\n    +import org.apache.curator.framework.CuratorFramework;<br/>\n    +import org.apache.curator.framework.api.BackgroundCallback;<br/>\n    +import org.apache.curator.framework.api.CuratorEvent;<br/>\n    +import org.apache.curator.framework.listen.ListenerContainer;<br/>\n    +import org.apache.curator.framework.state.ConnectionState;<br/>\n    +import org.apache.curator.framework.state.ConnectionStateListener;<br/>\n    +import org.apache.curator.utils.CloseableExecutorService;<br/>\n    +import org.apache.curator.utils.ThreadUtils;<br/>\n    +import org.apache.curator.utils.ZKPaths;<br/>\n    +import org.apache.zookeeper.KeeperException;<br/>\n    +import org.apache.zookeeper.WatchedEvent;<br/>\n    +import org.apache.zookeeper.Watcher;<br/>\n    +import org.apache.zookeeper.data.Stat;<br/>\n    +import org.slf4j.Logger;<br/>\n    +import org.slf4j.LoggerFactory;<br/>\n    +import java.io.Closeable;<br/>\n    +import java.io.IOException;<br/>\n    +import java.util.ArrayList;<br/>\n    +import java.util.Collections;<br/>\n    +import java.util.List;<br/>\n    +import java.util.SortedSet;<br/>\n    +import java.util.concurrent.ConcurrentMap;<br/>\n    +import java.util.concurrent.ExecutorService;<br/>\n    +import java.util.concurrent.Executors;<br/>\n    +import java.util.concurrent.ThreadFactory;<br/>\n    +import java.util.concurrent.atomic.AtomicLong;<br/>\n    +import java.util.concurrent.atomic.AtomicReference;<br/>\n    +<br/>\n    +/**<br/>\n    + * <p>A utility that attempts to keep all data from all children of a ZK path locally cached. This class<br/>\n    + * will watch the ZK path, respond to update/create/delete events, pull down the data, etc. You can<br/>\n    + * register a listener that will get notified when changes occur.</p><br/>\n    + * <p></p><br/>\n    + * <p><b>IMPORTANT</b> - it's not possible to stay transactionally in sync. Users of this class must<br/>\n    + * be prepared for false-positives and false-negatives. Additionally, always use the version number<br/>\n    + * when updating data to avoid overwriting another process' change.</p><br/>\n    + */<br/>\n    +public class TreeCache implements Closeable<br/>\n    +{<br/>\n    +    private static final Logger LOG = LoggerFactory.getLogger(TreeCache.class);<br/>\n    +<br/>\n    +    private enum NodeState<br/>\n    +    </p>\n{\n    +PENDING, LIVE, DEAD\n    +    }\n<p>    +<br/>\n    +    final class TreeNode implements Watcher, BackgroundCallback<br/>\n    +    {<br/>\n    +private final AtomicReference<NodeState> nodeState = new AtomicReference<NodeState>(NodeState.PENDING);<br/>\n    +private final String path;<br/>\n    +private final TreeNode parent;<br/>\n    +private final AtomicReference<Stat> stat = new AtomicReference<Stat>();<br/>\n    +private final AtomicReference<byte[]> data = new AtomicReference<byte[]>();<br/>\n    +private final AtomicReference<ConcurrentMap<String, TreeNode>> children = new AtomicReference<ConcurrentMap<String, TreeNode>>();<br/>\n    +<br/>\n    +TreeNode(String path, TreeNode parent)<br/>\n    +</p>\n{\n    +    this.path = path;\n    +    this.parent = parent;\n    +}\n<p>    +<br/>\n    +private void refreshChildren() throws Exception<br/>\n    +</p>\n{\n    +    outstandingOps.incrementAndGet();\n    +    client.getChildren().usingWatcher(this).inBackground(this).forPath(path);\n    +}\n<p>    +<br/>\n    +private void refreshData() throws Exception<br/>\n    +{<br/>\n    +    outstandingOps.incrementAndGet();<br/>\n    +    if ( dataIsCompressed )<br/>\n    +    </p>\n{\n    +client.getData().decompressed().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +    else<br/>\n    +    </p>\n{\n    +client.getData().usingWatcher(this).inBackground(this).forPath(path);\n    +    }\n<p>    +}<br/>\n    +<br/>\n    +private void wasReconnected() throws Exception<br/>\n    +{<br/>\n    +    refreshData();<br/>\n    +    refreshChildren();<br/>\n    +    ConcurrentMap<String, TreeNode> childMap = children.get();<br/>\n    +    if ( childMap != null )<br/>\n    +    {<br/>\n    +for ( TreeNode child : childMap.values() )<br/>\n    +</p>\n{\n    +    child.wasReconnected();\n    +}\n<p>    +    }<br/>\n    +}<br/>\n    +<br/>\n    +private void wasCreated() throws Exception<br/>\n    &#8212; End diff &#8211;</p>\n\n<p>    Done</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695794/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50913980","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50913980","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50913980,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTEzOTgw","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T17:47:37Z","updated_at":"2014-08-01T17:47:37Z","author_association":"CONTRIBUTOR","body":"Good find!  I'll look at the race conditions today.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50913980/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695800","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695800","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695800,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4MDA=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T17:47:44Z","updated_at":"2025-01-21T13:10:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50913980\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50913980</a></p>\n\n<p>    Good find!  I'll look at the race conditions today.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695800/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701465","html_url":"https://github.com/apache/curator/issues/592#issuecomment-2604701465","issue_url":"https://api.github.com/repos/apache/curator/issues/592","id":2604701465,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ3MDE0NjU=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T17:48:35Z","updated_at":"2025-01-21T13:13:09Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>GitHub user madrob opened a pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/31\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/31</a></p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-71\" title=\"Error message in StandardLockInternalsDriver for retryable lock acquire error\" class=\"issue-link\" data-issue-key=\"CURATOR-71\"><del>CURATOR-71</del></a> do not log-and-throw</p>\n\n<p>    If we throw an exception, then there is no point in logging it since<br/>\n    something further up the call stack already has to deal with it. At<br/>\n    best, the exception gets logged twice, at worst we log potentially<br/>\n    confusing exceptions that end up not mattering.</p>\n\n<p>You can merge this pull request into a Git repository by running:</p>\n\n<p>    $ git pull <a href=\"https://github.com/madrob/curator\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/madrob/curator</a> <a href=\"https://issues.apache.org/jira/browse/CURATOR-71\" title=\"Error message in StandardLockInternalsDriver for retryable lock acquire error\" class=\"issue-link\" data-issue-key=\"CURATOR-71\"><del>CURATOR-71</del></a></p>\n\n<p>Alternatively you can review and apply these changes as the patch at:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/31.patch\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/31.patch</a></p>\n\n<p>To close this pull request, make a commit to your master/trunk branch<br/>\nwith (at least) the following in the commit message:</p>\n\n<p>    This closes #31</p>\n\n<hr />\n<p>commit 35278cc1b52802995ee5db017bcc84dba7c69a70<br/>\nAuthor: Mike Drob <mdrob@cloudera.com><br/>\nDate:   2014-08-01T17:08:47Z</p>\n\n<p>    <a href=\"https://issues.apache.org/jira/browse/CURATOR-71\" title=\"Error message in StandardLockInternalsDriver for retryable lock acquire error\" class=\"issue-link\" data-issue-key=\"CURATOR-71\"><del>CURATOR-71</del></a> do not log-and-throw</p>\n\n<p>    If we throw an exception, then there is no point in logging it since<br/>\n    something further up the call stack already has to deal with it. At<br/>\n    best, the exception gets logged twice, at worst we log potentially<br/>\n    confusing exceptions that end up not mattering.</p>\n\n<hr />","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604701465/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50917378","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50917378","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50917378,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTE3Mzc4","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:18:04Z","updated_at":"2014-08-01T18:18:04Z","author_association":"CONTRIBUTOR","body":"Okay, the outstandingOps race was easy to resolve, I'm changing refresh() to do this:\n\n```\nprivate void refresh() throws Exception\n{\n    // Push an extra op so that a race between refreshData() response and\n    // refreshChildren() can't cause the outstanding ops to drop to zero.\n    try {\n        outstandingOps.incrementAndGet();\n        refreshData();\n        refreshChildren();\n    } finally {\n        outstandingOps.decrementAndGet();\n    }\n}\n```\n\nWith this I can add a Thread.sleep() at that start of refreshChildren() and there's no problem.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50917378/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695806","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695806","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695806,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4MDY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:18:10Z","updated_at":"2025-01-21T13:10:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50917378\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50917378</a></p>\n\n<p>    Okay, the outstandingOps race was easy to resolve, I'm changing refresh() to do this:</p>\n\n<p>    ```<br/>\n    private void refresh() throws Exception<br/>\n    {<br/>\n// Push an extra op so that a race between refreshData() response and<br/>\n// refreshChildren() can't cause the outstanding ops to drop to zero.<br/>\ntry </p>\n{\n    outstandingOps.incrementAndGet();\n    refreshData();\n    refreshChildren();\n}\n<p> finally </p>\n{\n    outstandingOps.decrementAndGet();\n}\n<p>    }<br/>\n    ```</p>\n\n<p>    With this I can add a Thread.sleep() at that start of refreshChildren() and there's no problem.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695806/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50917549","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50917549","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50917549,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTE3NTQ5","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:19:41Z","updated_at":"2014-08-01T18:20:41Z","author_association":"MEMBER","body":"I think that introduces a new problem. What if the background callback executes before the finally block. The initial event notification won't get sent until there's a change in the tree.\n\nI think you need to increment the outstandingOps count by 2 and then do refreshData and refreshChildren. This will require some reworking though.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50917549/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695809","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695809","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695809,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4MDk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:19:51Z","updated_at":"2025-01-21T13:10:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50917549\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50917549</a></p>\n\n<p>    I think that introduces a new problem. What if the background callback executes before the finally block. The initial event notification won't get sent until there's a change in the tree.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695809/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50918169","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50918169","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50918169,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTE4MTY5","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:25:02Z","updated_at":"2014-08-01T18:25:02Z","author_association":"CONTRIBUTOR","body":"So I looked through the issue you described with respect to wasReconnected() being called concurrently with refreshData / refreshChildren.  I can't actually see any potential problems with this.  None of the code paths from wasReconnected()/wasCreated()/wasDeleted() perform any mutations, all they ultimately do is queue up ZK operations which fire on the serialized background response thread.  The background response thread is the only thread that mutates the tree.\n\nDo you see something I'm missing?\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50918169/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695818","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695818","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695818,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4MTg=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:25:10Z","updated_at":"2025-01-21T13:10:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50918169\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50918169</a></p>\n\n<p>    So I looked through the issue you described with respect to wasReconnected() being called concurrently with refreshData / refreshChildren.  I can't actually see any potential problems with this.  None of the code paths from wasReconnected()/wasCreated()/wasDeleted() perform any mutations, all they ultimately do is queue up ZK operations which fire on the serialized background response thread.  The background response thread is the only thread that mutates the tree.</p>\n\n<p>    Do you see something I'm missing?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695818/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50918370","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50918370","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50918370,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTE4Mzcw","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:26:49Z","updated_at":"2014-08-01T18:26:49Z","author_association":"CONTRIBUTOR","body":"Good call, will do.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50918370/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695826","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695826","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695826,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4MjY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:26:59Z","updated_at":"2025-01-21T13:10:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50918370\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50918370</a></p>\n\n<p>    Good call, will do.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695826/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50918629","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50918629","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50918629,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTE4NjI5","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:28:53Z","updated_at":"2014-08-01T18:28:53Z","author_association":"MEMBER","body":"Imagine a scenario where there is a temporary connection problem. Curator will send SUSPENDED. If the connect gets repaired and the session survives, Curator will send RECONNECTED. At nearly the same time, some of the watchers might get called due to watched changes. Thus, a method like refreshData() might get called simultaneously by two threads.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50918629/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695829","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695829","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695829,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4Mjk=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:29:00Z","updated_at":"2025-01-21T13:10:43Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50918629\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50918629</a></p>\n\n<p>    Imagine a scenario where there is a temporary connection problem. Curator will send SUSPENDED. If the connect gets repaired and the session survives, Curator will send RECONNECTED. At nearly the same time, some of the watchers might get called due to watched changes. Thus, a method like refreshData() might get called simultaneously by two threads.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695829/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50919247","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50919247","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50919247,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTE5MjQ3","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:34:34Z","updated_at":"2014-08-01T18:34:34Z","author_association":"CONTRIBUTOR","body":"Yes, and I think that's okay.  refreshData() should be concurrency safe.  All it does is atomically increment the outstanding ops (so no race there), then queue up a curator background operation, e.g.\n\n`client.getData().usingWatcher(this).inBackground(this).forPath(path);`\n\nThere's no reason this would be a problem, right?  path is final so it won't change, CuratorFramework itself should be thread safe, and if the same operation happens twice at the same time, the callbacks will still come back in serial, and the second (duplicate) result should be the same and not produce an event.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50919247/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695833","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695833","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695833,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4MzM=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:34:41Z","updated_at":"2025-01-21T13:10:44Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50919247\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50919247</a></p>\n\n<p>    Yes, and I think that's okay.  refreshData() should be concurrency safe.  All it does is atomically increment the outstanding ops (so no race there), then queue up a curator background operation, e.g.</p>\n\n<p>    `client.getData().usingWatcher(this).inBackground(this).forPath(path);`</p>\n\n<p>    There's no reason this would be a problem, right?  path is final so it won't change, CuratorFramework itself should be thread safe, and if the same operation happens twice at the same time, the callbacks will still come back in serial, and the second (duplicate) result should be the same and not produce an event.</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695833/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50919952","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50919952","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50919952,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTE5OTUy","user":{"login":"Randgalt","id":264818,"node_id":"MDQ6VXNlcjI2NDgxOA==","avatar_url":"https://avatars.githubusercontent.com/u/264818?v=4","gravatar_id":"","url":"https://api.github.com/users/Randgalt","html_url":"https://github.com/Randgalt","followers_url":"https://api.github.com/users/Randgalt/followers","following_url":"https://api.github.com/users/Randgalt/following{/other_user}","gists_url":"https://api.github.com/users/Randgalt/gists{/gist_id}","starred_url":"https://api.github.com/users/Randgalt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Randgalt/subscriptions","organizations_url":"https://api.github.com/users/Randgalt/orgs","repos_url":"https://api.github.com/users/Randgalt/repos","events_url":"https://api.github.com/users/Randgalt/events{/privacy}","received_events_url":"https://api.github.com/users/Randgalt/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:40:59Z","updated_at":"2014-08-01T18:40:59Z","author_association":"MEMBER","body":"What about wasDeleted()?\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50919952/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695842","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695842","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695842,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4NDI=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:41:07Z","updated_at":"2025-01-21T13:10:44Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user Randgalt commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50919952\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50919952</a></p>\n\n<p>    What about wasDeleted()?</p>","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695842/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/50920900","html_url":"https://github.com/apache/curator/pull/17#issuecomment-50920900","issue_url":"https://api.github.com/repos/apache/curator/issues/17","id":50920900,"node_id":"MDEyOklzc3VlQ29tbWVudDUwOTIwOTAw","user":{"login":"dragonsinth","id":1919660,"node_id":"MDQ6VXNlcjE5MTk2NjA=","avatar_url":"https://avatars.githubusercontent.com/u/1919660?v=4","gravatar_id":"","url":"https://api.github.com/users/dragonsinth","html_url":"https://github.com/dragonsinth","followers_url":"https://api.github.com/users/dragonsinth/followers","following_url":"https://api.github.com/users/dragonsinth/following{/other_user}","gists_url":"https://api.github.com/users/dragonsinth/gists{/gist_id}","starred_url":"https://api.github.com/users/dragonsinth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dragonsinth/subscriptions","organizations_url":"https://api.github.com/users/dragonsinth/orgs","repos_url":"https://api.github.com/users/dragonsinth/repos","events_url":"https://api.github.com/users/dragonsinth/events{/privacy}","received_events_url":"https://api.github.com/users/dragonsinth/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:48:38Z","updated_at":"2014-08-01T18:48:38Z","author_association":"CONTRIBUTOR","body":"wasDeleted() can only be called from the watch event / background result thread, not the connection state listener.  It is true it can be called concurrently from TreeCache.close(), but I believe wasDeleted() is completely idempotent / concurrency safe.\n\nThe first several operations are completely idempotent, it's harmless to run them multiple times.  After that, there's an escape hatch if the tree is closing (which will have already been set in the TreeCache.close() case).  After THAT, there's a an atomic compare-and-set to publish a delete event, which only one thread can win.  And the remainder of the method is also idempotent.\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/50920900/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695846","html_url":"https://github.com/apache/curator/issues/554#issuecomment-2604695846","issue_url":"https://api.github.com/repos/apache/curator/issues/554","id":2604695846,"node_id":"MDEyOklzc3VlQ29tbWVudDI2MDQ2OTU4NDY=","user":{"login":"jira-importer","id":99357308,"node_id":"U_kgDOBewSfA","avatar_url":"https://avatars.githubusercontent.com/u/99357308?v=4","gravatar_id":"","url":"https://api.github.com/users/jira-importer","html_url":"https://github.com/jira-importer","followers_url":"https://api.github.com/users/jira-importer/followers","following_url":"https://api.github.com/users/jira-importer/following{/other_user}","gists_url":"https://api.github.com/users/jira-importer/gists{/gist_id}","starred_url":"https://api.github.com/users/jira-importer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jira-importer/subscriptions","organizations_url":"https://api.github.com/users/jira-importer/orgs","repos_url":"https://api.github.com/users/jira-importer/repos","events_url":"https://api.github.com/users/jira-importer/events{/privacy}","received_events_url":"https://api.github.com/users/jira-importer/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2014-08-01T18:48:47Z","updated_at":"2025-01-21T13:10:44Z","author_association":"COLLABORATOR","body":"<i><a href=\"https://issues.apache.org/jira/secure/ViewProfile.jspa?name=githubbot\">githubbot</a>:</i>\n<p>Github user dragonsinth commented on the pull request:</p>\n\n<p>    <a href=\"https://github.com/apache/curator/pull/17#issuecomment-50920900\" class=\"external-link\" target=\"_blank\" rel=\"nofollow noopener\">https://github.com/apache/curator/pull/17#issuecomment-50920900</a></p>\n\n<p>    wasDeleted() can only be called from the watch event / background result thread, not the connection state listener.  It is true it can be called concurrently from TreeCache.close(), but I believe wasDeleted() is completely idempotent / concurrency safe.</p>\n\n<p>    The first several operations are completely idempotent, it's harmless to run them multiple times.  After that, there's an escape hatch if the tree is closing (which will have already been set in the TreeCache.close() case).  After THAT, there's a an atomic compare-and-set to publish a delete event, which only one thread can win.  And the remainder of the method is also idempotent.</p>\n","reactions":{"url":"https://api.github.com/repos/apache/curator/issues/comments/2604695846/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]